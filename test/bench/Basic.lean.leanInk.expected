[{"contents":
  "/-\nCopyright (c) 2014 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn, Leonardo de Moura\n-/\nprelude\nimport Init.SimpLemmas\nuniverse u\n\n-- this is a copy of leanprover/lean4/src/Init/Data/Nat/Basic.lean\nnamespace Nat\n\n@[specialize] def foldAux {Î± : Type u} (f : Nat â†’ Î± â†’ Î±) (s : Nat) : Nat â†’ Î± â†’ Î±\n  | 0,      a => a\n  | succ n, a => foldAux f s n (f (s - (succ n)) a)\n\n@[inline] def fold {Î± : Type u} (f : Nat â†’ Î± â†’ Î±) (n : Nat) (init : Î±) : Î± :=\n  foldAux f n n init\n\n@[inline] def foldRev {Î± : Type u} (f : Nat â†’ Î± â†’ Î±) (n : Nat) (init : Î±) : Î± :=\n  let rec @[specialize] loop\n    | 0,      a => a\n    | succ n, a => loop n (f n a)\n  loop n init\n\n@[specialize] def anyAux (f : Nat â†’ Bool) (s : Nat) : Nat â†’ Bool\n  | 0      => false\n  | succ n => f (s - (succ n)) || anyAux f s n\n\n/-- `any f n = true` iff there is `i in [0, n-1]` s.t. `f i = true` -/\n@[inline] def any (f : Nat â†’ Bool) (n : Nat) : Bool :=\n  anyAux f n n\n\n@[inline] def all (f : Nat â†’ Bool) (n : Nat) : Bool :=\n  !any (fun i => !f i) n\n\n@[inline] def repeat {Î± : Type u} (f : Î± â†’ Î±) (n : Nat) (a : Î±) : Î± :=\n  let rec @[specialize] loop\n    | 0,      a => a\n    | succ n, a => loop n (f a)\n  loop n a\n\ndef blt (a b : Nat) : Bool :=\n  ble a.succ b\n\nattribute [simp] Nat.zero_le\n\n/-! # Helper \"packing\" theorems -/\n\n@[simp] theorem zero_eq : Nat.zero = 0 := rfl\n@[simp] theorem add_eq : Nat.add x y = x + y := rfl\n@[simp] theorem mul_eq : Nat.mul x y = x * y := rfl\n@[simp] theorem sub_eq : Nat.sub x y = x - y := rfl\n@[simp] theorem lt_eq : Nat.lt x y = (x < y) := rfl\n@[simp] theorem le_eq : Nat.le x y = (x â‰¤ y) := rfl\n\n/-! # Helper Bool relation theorems -/\n\n@[simp] theorem beq_refl (a : Nat) : Nat.beq a a = true := ",
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat â†’ Nat â†’ Bool", "name": "Nat.beq", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.beq",
    "link": null,
    "docstring":
    "(Boolean) equality of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "beq a a = true",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "beq a a = true", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "beq a a = true", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {x y : Nat}, (beq x y = true) = (x = y)",
     "name": "beq_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "beq_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat â†’ Nat â†’ Bool", "name": "Nat.beq", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.beq",
    "link": null,
    "docstring":
    "(Boolean) equality of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring":
    "The boolean value `true`, not to be confused with the proposition `True`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†” b) â†’ a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring":
    "The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a âˆ§ c âˆ¨ d â†’ e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop â†’ Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True â†’ True) â†” True := âŸ¨Î» _ => trivial, Î» _ _ => trivialâŸ©\n  have := propext this â–¸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } â–¸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ (a â†” b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": "If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, beq n m = true â†’ n = m",
     "name": "Nat.eq_of_beq_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_of_beq_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "x = y", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "x = y", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a : Nat), beq a a = true",
     "name": "Nat.beq_refl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.beq_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "))\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {x y : Nat}, (ble x y = true) = (x â‰¤ y)",
     "name": "ble_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ble_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat â†’ Nat â†’ Bool", "name": "Nat.ble", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ble",
    "link": null,
    "docstring":
    "The (Boolean) less-equal relation on natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring":
    "The boolean value `true`, not to be confused with the proposition `True`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†” b) â†’ a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring":
    "The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a âˆ§ c âˆ¨ d â†’ e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop â†’ Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True â†’ True) â†” True := âŸ¨Î» _ => trivial, Î» _ _ => trivialâŸ©\n  have := propext this â–¸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } â–¸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ (a â†” b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": "If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, ble n m = true â†’ n â‰¤ m",
     "name": "Nat.le_of_ble_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_ble_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ ble n m = true",
     "name": "Nat.ble_eq_true_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ble_eq_true_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {x y : Nat}, (blt x y = true) = (x < y)",
     "name": "blt_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "blt_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat â†’ Nat â†’ Bool", "name": "Nat.blt", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.blt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring":
    "The boolean value `true`, not to be confused with the proposition `True`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†” b) â†’ a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring":
    "The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a âˆ§ c âˆ¨ d â†’ e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop â†’ Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True â†’ True) â†” True := âŸ¨Î» _ => trivial, Î» _ _ => trivialâŸ©\n  have := propext this â–¸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } â–¸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ (a â†” b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": "If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, ble n m = true â†’ n â‰¤ m",
     "name": "Nat.le_of_ble_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_ble_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ ble n m = true",
     "name": "Nat.ble_eq_true_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ble_eq_true_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "LawfulBEq Nat", "name": "instance", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Î± : Type) â†’ [inst : BEq Î±] â†’ Prop",
     "name": "LawfulBEq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LawfulBEq",
    "link": null,
    "docstring":
    "`LawfulBEq Î±` is a typeclass which asserts that the `BEq Î±` implementation\n(which supplies the `a == b` notation) coincides with logical equality `a = b`.\nIn other words, `a == b` implies `a = b`, and `a == a` is true.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "eq_of_beq",
    "link": null,
    "docstring":
    "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(aâœ == bâœ) = true", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, beq n m = true â†’ n = m",
     "name": "Nat.eq_of_beq_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_of_beq_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(aâœ == bâœ) = true", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": "`==` is reflexive, that is, `(a == a) = true`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "âˆ€ {a : Nat}, (a == a) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "{Î± : Type ?u.3347} â†’ [self : BEq Î±] â†’ Î± â†’ Î± â†’ Bool",
     "name": "BEq.beq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "BEq.beq",
    "link": null,
    "docstring": "Boolean equality, notated as `a == b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a b : Nat), ((a == b) = true) = (a = b)",
     "name": "beq_eq_true_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "beq_eq_true_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " == ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring":
    "The boolean value `true`, not to be confused with the proposition `True`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†” b) â†’ a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring":
    "The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a âˆ§ c âˆ¨ d â†’ e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop â†’ Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True â†’ True) â†” True := âŸ¨Î» _ => trivial, Î» _ _ => trivialâŸ©\n  have := propext this â–¸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } â–¸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ (a â†” b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": "If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "âˆ€ {Î± : Type} [inst : BEq Î±] [self : LawfulBEq Î±] {a b : Î±}, (a == b) = true â†’ a = b",
     "name": "eq_of_beq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "eq_of_beq",
    "link": null,
    "docstring":
    "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a = b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == b) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == a) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "subst",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == a) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a = b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == b) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type":
     "âˆ€ {Î± : Type} [inst : BEq Î±] [self : LawfulBEq Î±] {a : Î±}, (a == a) = true",
     "name": "LawfulBEq.rfl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LawfulBEq.rfl",
    "link": null,
    "docstring": "`==` is reflexive, that is, `(a == a) = true`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ")\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a b : Nat), ((!a == b) = true) = Â¬a = b",
     "name": "not_beq_eq_true_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_beq_eq_true_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ((!(",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " == ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring":
    "The boolean value `true`, not to be confused with the proposition `True`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = Â¬(",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†” b) â†’ a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring":
    "The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a âˆ§ c âˆ¨ d â†’ e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop â†’ Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True â†’ True) â†” True := âŸ¨Î» _ => trivial, Î» _ _ => trivialâŸ©\n  have := propext this â–¸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } â–¸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ (a â†” b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": "If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(!a == b) = true", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == b) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = b", "names": ["hâ‚‚"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == a) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "subst",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == a) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == b) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = b", "names": ["hâ‚‚"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == a) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type":
     "âˆ€ {Î± : Type} [inst : BEq Î±] [self : LawfulBEq Î±] {a : Î±}, (a == a) = true",
     "name": "LawfulBEq.rfl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LawfulBEq.rfl",
    "link": null,
    "docstring": "`==` is reflexive, that is, `(a == a) = true`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "(!a == a) = true", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == b) = true",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = b", "names": ["hâ‚‚"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : Â¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x â‰  x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : Â¬ ((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " == ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring":
    "The boolean value `true`, not to be confused with the proposition `True`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(a == b) = true", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "âˆ€ {Î± : Type} [inst : BEq Î±] [self : LawfulBEq Î±] {a b : Î±}, (a == b) = true â†’ a = b",
     "name": "eq_of_beq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "eq_of_beq",
    "link": null,
    "docstring":
    "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(a == b) = true", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "Â¬a = b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Â¬(a == b) = true",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(!a == b) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "Â¬(a == b) = true", "name": "this", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n/-! # Nat.add theorems -/\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 + n = n", "name": "zero_add", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± Î² : Type} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring":
    "Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing aâ‚> = <something containing aâ‚‚>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± Î² : Type} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring":
    "Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing aâ‚> = <something containing aâ‚‚>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n + 1 = succ n",
     "name": "add_one",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), succ n = n + 1",
     "name": "succ_eq_add_one",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_eq_add_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "add_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "Eq.symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Eq.symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (n + m) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m = m + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± Î² : Type} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring":
    "Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing aâ‚> = <something containing aâ‚‚>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m = m + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (n + m) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ (n + m) = succ (m + n)",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ (n + m) = succ (m + n)",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ (n + m) = succ (m + n)",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ (n + m) = succ (m + n)",
     "name": "this",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "add_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | _, _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± Î² : Type} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring":
    "Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing aâ‚> = <something containing aâ‚‚>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "add_left_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m + n + k = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m + (n + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + k + m",
     "name": "add_right_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_right_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (k + m) = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k + m = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + m = n + k â†’ m = k",
     "name": "add_left_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_left_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + m = zero + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + m = zero + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "m = k", "names": ["aâœ"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intros",
    "link": null,
    "docstring":
    "`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous)\nhypotheses until goal is not of a function type.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "m = k", "names": ["aâœ"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + m = zero + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `â€¹tâ€º` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k â†’ m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n + m = succ n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + m = n + k â†’ m = k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k â†’ m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k â†’ m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k â†’ m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n + m = succ n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k â†’ m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + m = n + k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k â†’ m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k â†’ m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n + m = succ n + k â†’ m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + m = n + k â†’ m = k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + m = n + k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + m = k + m â†’ n = k",
     "name": "add_right_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_right_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + m = k + m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = m + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = m + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = m + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m + n = k + m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + m = n + k â†’ m = k",
     "name": "Nat.add_left_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m + n = m + k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  "\n\n/-! # Nat.mul theorems -/\n\n@[simp] protected theorem mul_zero (n : Nat) : n * 0 = 0 :=\n  rfl\n\ntheorem mul_succ (n m : Nat) : n * succ m = n * m + n :=\n  rfl\n\n@[simp] protected theorem zero_mul : âˆ€ (n : Nat), 0 * n = 0\n  | 0      => rfl\n  | succ n => mul_succ 0 n â–¸ (Nat.zero_mul n).symm â–¸ rfl\n\ntheorem succ_mul (n m : Nat) : (succ n) * m = (n * m) + m := ",
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * m = n * m + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * m = n * m + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * zero = n * zero + zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl` tries to close the current goal using reflexivity.\nThis is supposed to be an extensible tactic and users can add their own support\nfor new reflexive relations.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * m = n * m + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ n * m = n * m + m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * m + succ n = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (succ n * m + n) = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + m + n) = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "succ n * m = n * m + m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + m + n) = n * m + n + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + m + n) = succ (n * m + n + m)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + n + m) = succ (n * m + n + m)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + k + m",
     "name": "Nat.add_right_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_right_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "mul_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 * n = 0",
     "name": "Nat.zero_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n * 0 = 0",
     "name": "Nat.mul_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n * 1 = n", "name": "mul_one", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 1 * n = n", "name": "one_mul", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "one_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n * 1 = n",
     "name": "Nat.mul_one",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "left_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m + k) = n * m + n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m + k) = n * m + n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "generalizing",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero * (m + k) = zero * m + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero * (m + k) = zero * m + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "repeat",
    "link": null,
    "docstring":
    "`repeat tac` applies `tac` to main goal. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`repeat tac` applies `tac` to main goal. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0 + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 * n = 0",
     "name": "Nat.zero_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_mul",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = zero * m + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m + k) = n * m + n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
     "name": "ih",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
     "name": "ih",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + (m + (n * k + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "*",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + (m + (n * k + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + (m + (n * k + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ.h",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * k + (m + k) = m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± Î² : Type} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring":
    "Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing aâ‚> = <something containing aâ‚‚>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ.h",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * k + (m + k) = m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "âˆ€ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "Nat.add_left_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), (n + m) * k = n * k + m * k",
     "name": "right_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n + m) * k = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n + m) * k = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k * (n + m) = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n + m) * k = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k * n + k * m = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k * n + k * m = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k * n + k * m = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n + m) * k = n * k + m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "mul_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), (n + m) * k = n * k + m * k",
     "name": "add_mul",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), (n + m) * k = n * k + m * k",
     "name": "Nat.right_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "mul_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * succ k = n * (m * succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "Nat.mul_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * (m * k) = m * (n * k)",
     "name": "mul_left_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * k = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "Nat.mul_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m * n * k = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m * (n * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "Nat.mul_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  "\n\n/-! # Inequalities -/\n\nattribute [simp] Nat.le_refl\n\ntheorem succ_lt_succ {n m : Nat} : n < m â†’ succ n < succ m :=\n  succ_le_succ\n\ntheorem lt_succ_of_le {n m : Nat} : n â‰¤ m â†’ n < succ m :=\n  succ_le_succ\n\n@[simp] protected theorem sub_zero (n : Nat) : n - 0 = n :=\n  rfl\n\ntheorem succ_sub_succ_eq_sub (n m : Nat) : succ n - succ m = n - m := ",
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ zero = n - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n - succ m = n - m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n - succ (succ m) = n - succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ n - succ m = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± Î² : Type} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring":
    "Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing aâ‚> = <something containing aâ‚‚>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ n - succ m = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), pred n â‰¤ n", "name": "pred_le", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n : Nat}, Nat.le n n",
     "name": "Nat.le.refl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le.refl",
    "link": null,
    "docstring": "Less-equal is reflexive: `n â‰¤ n` ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " _ => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n â‰¤ succ n", "name": "le_succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n : Nat}, n â‰  0 â†’ pred n < n",
     "name": "pred_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "zero â‰  0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "zero â‰  0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " _, _ => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n < succ m",
     "name": "lt_succ_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt_succ_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n â‰¤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - m â‰¤ n", "name": "sub_le", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m â‰¤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m â‰¤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - zero â‰¤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n â‰¤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m â‰¤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n - m â‰¤ n", "names": ["ih"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - succ m â‰¤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n - m â‰¤ n", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), pred n â‰¤ n", "name": "pred_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n - m â‰¤ n", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, 0 < n â†’ 0 < m â†’ n - m < n",
     "name": "sub_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   _,   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h1", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", _  => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h1", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h2", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "  => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h2", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1, _,  _  =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "Eq.symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Eq.symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ_eq_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ_eq_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") â–¸\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "from",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n < succ m",
     "name": "lt_succ_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt_succ_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - m â‰¤ n", "name": "sub_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "sub_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "sub_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ_eq_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ_eq_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n - n = 0", "name": "sub_self", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "        => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "", "hypotheses": [], "conclusion": "0 - 0 = 0", "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "", "hypotheses": [], "conclusion": "0 - 0 = 0", "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "", "hypotheses": [], "conclusion": "0 = 0", "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), n - 0 = n",
     "name": "Nat.sub_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_zero",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), n - n = 0",
     "name": "Nat.sub_self",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.sub_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m â‰¤ k â†’ n < k",
     "name": "lt_of_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m = k â†’ n < k",
     "name": "lt_of_lt_of_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_lt_of_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = k", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = k", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun x x_1 => x < x_1) (fun x x_1 => x < x_1) fun x x_1 => x < x_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{Î± Î² Î³ : Type} â†’ (Î± â†’ Î² â†’ Prop) â†’ (Î² â†’ Î³ â†’ Prop) â†’ outParam (Î± â†’ Î³ â†’ Prop) â†’ Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring":
    "Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a â‰¤ b` and `b < c`\nit knows that this should be a proof of `a < c` because there is an instance\n`Trans (Â·â‰¤Â·) (Â·<Â·) (Â·<Â·)`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring":
    "Compose two proofs by transitivity, generalized over the relations involved. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m < k â†’ n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun x x_1 => x â‰¤ x_1) (fun x x_1 => x â‰¤ x_1) fun x x_1 => x â‰¤ x_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{Î± Î² Î³ : Type} â†’ (Î± â†’ Î² â†’ Prop) â†’ (Î² â†’ Î³ â†’ Prop) â†’ outParam (Î± â†’ Î³ â†’ Prop) â†’ Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring":
    "Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a â‰¤ b` and `b < c`\nit knows that this should be a proof of `a < c` because there is an instance\n`Trans (Â·â‰¤Â·) (Â·<Â·) (Â·<Â·)`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. â‰¤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. â‰¤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. â‰¤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring":
    "Compose two proofs by transitivity, generalized over the relations involved. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun x x_1 => x < x_1) (fun x x_1 => x â‰¤ x_1) fun x x_1 => x < x_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{Î± Î² Î³ : Type} â†’ (Î± â†’ Î² â†’ Prop) â†’ (Î² â†’ Î³ â†’ Prop) â†’ outParam (Î± â†’ Î³ â†’ Prop) â†’ Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring":
    "Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a â‰¤ b` and `b < c`\nit knows that this should be a proof of `a < c` because there is an instance\n`Trans (Â·â‰¤Â·) (Â·<Â·) (Â·<Â·)`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. â‰¤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring":
    "Compose two proofs by transitivity, generalized over the relations involved. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m â‰¤ k â†’ n < k",
     "name": "Nat.lt_of_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun x x_1 => x â‰¤ x_1) (fun x x_1 => x < x_1) fun x x_1 => x < x_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{Î± Î² Î³ : Type} â†’ (Î± â†’ Î² â†’ Prop) â†’ (Î² â†’ Î³ â†’ Prop) â†’ outParam (Î± â†’ Î³ â†’ Prop) â†’ Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring":
    "Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a â‰¤ b` and `b < c`\nit knows that this should be a proof of `a < c` because there is an instance\n`Trans (Â·â‰¤Â·) (Â·<Â·) (Â·<Â·)`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. â‰¤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring":
    "Compose two proofs by transitivity, generalized over the relations involved. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m < k â†’ n < k",
     "name": "Nat.lt_of_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n = m â†’ n â‰¤ m",
     "name": "le_of_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n â‰¤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ m â†’ n â‰¤ m",
     "name": "le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n â‰¤ succ n", "name": "le_succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ n â‰¤ m",
     "name": "le_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ m â†’ n â‰¤ m",
     "name": "le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ n < succ m",
     "name": "lt.step",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt.step",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n â‰¤ succ m",
     "name": "le_step",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_step",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n = 0 âˆ¨ n > 0",
     "name": "eq_zero_or_pos",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_zero_or_pos",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " âˆ¨ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 < succ n",
     "name": "succ_pos",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_pos",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n < succ n", "name": "lt.base", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt.base",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n â‰¤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n < succ n",
     "name": "lt_succ_self",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_succ_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n < succ n", "name": "lt.base", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt.base",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (m n : Nat), m â‰¤ n âˆ¨ n â‰¤ m",
     "name": "le_total",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_total",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " âˆ¨ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n < m âˆ¨ n â‰¥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ n â‰¤ m",
     "name": "Nat.le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¥ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¥ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n : Nat}, n â‰¤ 0 â†’ n = 0",
     "name": "eq_zero_of_le_zero",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_zero_of_le_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ m â‰¤ n â†’ n = m",
     "name": "Nat.le_antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_antisymm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 â‰¤ n", "name": "zero_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n < m â†’ n < m",
     "name": "lt_of_succ_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_succ_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ m â†’ n â‰¤ m",
     "name": "le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n < succ m â†’ n < m",
     "name": "lt_of_succ_lt_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_succ_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ succ m â†’ n â‰¤ m",
     "name": "le_of_succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ m â†’ n < m",
     "name": "lt_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ succ n â‰¤ m",
     "name": "succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a < b â†’ 0 < b",
     "name": "zero_lt_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < xâœ", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < xâœ", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + 1 < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m < k â†’ n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n < succ n",
     "name": "Nat.lt_succ_self",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_succ_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + 1 < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a < b â†’ 0 < b",
     "name": "zero_lt_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a : Nat}, a â‰  0 â†’ 0 < a",
     "name": "zero_lt_of_ne_zero",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_of_ne_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a â‰  0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "0 â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : Â¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x â‰  x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["aâœ", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + 1 â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a + 1",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1 =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 < succ n",
     "name": "Nat.zero_lt_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "attribute",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a < b â†’ a â‰  b",
     "name": "ne_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ne_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "he", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "he",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "he", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "he",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {m n : Nat}, m â‰¤ succ n â†’ m â‰¤ n âˆ¨ m = succ n",
     "name": "le_or_eq_of_le_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_or_eq_of_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¤ succ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " âˆ¨ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {p q : Prop} [dec : Decidable p], (p â†’ q) â†’ (Â¬p â†’ q) â†’ q",
     "name": "Decidable.byCases",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Decidable.byCases",
    "link": null,
    "docstring":
    "Synonym for `dite` (dependent if-then-else). We can construct an element `q`\n(of any sort, not just a proposition) by cases on whether `p` is true or false,\nprovided `p` is decidable.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰  succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") =>\n       ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Â¬n = m â†’ n < m",
     "name": "Nat.lt_of_le_of_ne",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_le_of_ne",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¤ succ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰  succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n       ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ succ n â‰¤ m",
     "name": "succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < succ n", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n       ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ succ m â†’ n â‰¤ m",
     "name": "le_of_succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "succ m â‰¤ succ n", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "))\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n k : Nat), n â‰¤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n â‰¤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n â‰¤ succ m",
     "name": "le_succ_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_succ_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n k : Nat), n â‰¤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n â‰¤ m + n",
     "name": "le_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "): ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n k : Nat), n â‰¤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : âˆ€ {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{Î± : Type} â†’ (Î± â†’ Prop) â†’ Prop",
     "name": "Exists",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Exists",
    "link": null,
    "docstring":
    "Existential quantification. If `p : Î± â†’ Prop` is a predicate, then `âˆƒ x : Î±, p x`\nasserts that there is some `x` of type `Î±` such that `p x` holds.\nTo create an existential proof, use the `exists` tactic,\nor the anonymous constructor notation `âŸ¨x, hâŸ©`.\nTo unpack an existential, use `cases h` where `h` is a proof of `âˆƒ x : Î±, p x`,\nor `let âŸ¨x, hxâŸ© := h` where `.\n\nBecause Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:\n```\nexample (h : âˆƒ x : Nat, x = x) : Nat :=\n  let âŸ¨x, _âŸ© := h  -- fail, because the goal is `Nat : Type`\n  x\n```\nThe error message `recursor 'Exists.casesOn' can only eliminate into Prop` means\nthat this only works when the current goal is another proposition:\n```\nexample (h : âˆƒ x : Nat, x = x) : True :=\n  let âŸ¨x, _âŸ© := h  -- ok, because the goal is `True : Prop`\n  trivial\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   _ => âŸ¨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ©\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", _ => âŸ¨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ©\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ nâœ â‰¤ zero", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ nâœ â‰¤ zero", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), succ n â‰¤ 0 â†’ False",
     "name": "not_succ_le_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "not_succ_le_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n â‰¤ succ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ succ m â†’ n â‰¤ m",
     "name": "Nat.le_of_succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n â‰¤ succ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{Î± : Type} â†’ (Î± â†’ Prop) â†’ Prop",
     "name": "Exists",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Exists",
    "link": null,
    "docstring":
    "Existential quantification. If `p : Î± â†’ Prop` is a predicate, then `âˆƒ x : Î±, p x`\nasserts that there is some `x` of type `Î±` such that `p x` holds.\nTo create an existential proof, use the `exists` tactic,\nor the anonymous constructor notation `âŸ¨x, hâŸ©`.\nTo unpack an existential, use `cases h` where `h` is a proof of `âˆƒ x : Î±, p x`,\nor `let âŸ¨x, hxâŸ© := h` where `.\n\nBecause Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:\n```\nexample (h : âˆƒ x : Nat, x = x) : Nat :=\n  let âŸ¨x, _âŸ© := h  -- fail, because the goal is `Nat : Type`\n  x\n```\nThe error message `recursor 'Exists.casesOn' can only eliminate into Prop` means\nthat this only works when the current goal is another proposition:\n```\nexample (h : âˆƒ x : Nat, x = x) : True :=\n  let âŸ¨x, _âŸ© := h  -- ok, because the goal is `True : Prop`\n  trivial\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "dest",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Exists fun k => n + k = m", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | âŸ¨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ© => âŸ¨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "from",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")âŸ©\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + k = m â†’ n â‰¤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n k : Nat), n â‰¤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n > m â†’ Â¬n â‰¤ m",
     "name": "not_le_of_gt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_le_of_gt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : Â¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n < m âˆ¨ n â‰¥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m < k â†’ n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¥ m", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "Heq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Heq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ m â‰¤ n â†’ n = m",
     "name": "Nat.le_antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_antisymm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¥ m", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (@",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "âˆ€ {Î± : Type} {motive : Î± â†’ Prop} {a b : Î±}, a = b â†’ motive a â†’ motive b",
     "name": "Eq.subst",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Eq.subst",
    "link": null,
    "docstring":
    "The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x => x < 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Prop", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "Heq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Heq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, Â¬n â‰¤ m â†’ n > m",
     "name": "gt_of_not_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "gt_of_not_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : Â¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n < m âˆ¨ n â‰¥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¥ n", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¥ n", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, Â¬n < m â†’ n â‰¥ m",
     "name": "ge_of_not_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ge_of_not_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : Â¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¥ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n < m âˆ¨ n â‰¥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¥ m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¥ m", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Antisymm fun x x_1 => x â‰¤ x_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{Î± : Type} â†’ (Î± â†’ Î± â†’ Prop) â†’ Type",
     "name": "Antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Antisymm",
    "link": null,
    "docstring":
    "`Antisymm (Â·â‰¤Â·)` says that `(Â·â‰¤Â·)` is antisymmetric, that is, `a â‰¤ b â†’ b â‰¤ a â†’ a = b`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ( . â‰¤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "antisymm",
    "link": null,
    "docstring":
    "An antisymmetric relation `(Â·â‰¤Â·)` satisfies `a â‰¤ b â†’ b â‰¤ a â†’ a = b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "aâœ â‰¤ bâœ", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "bâœ â‰¤ aâœ", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ m â‰¤ n â†’ n = m",
     "name": "Nat.le_antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_antisymm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "aâœ â‰¤ bâœ", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "bâœ â‰¤ aâœ", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Antisymm fun x x_1 => Â¬x < x_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{Î± : Type} â†’ (Î± â†’ Î± â†’ Prop) â†’ Type",
     "name": "Antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Antisymm",
    "link": null,
    "docstring":
    "`Antisymm (Â·â‰¤Â·)` says that `(Â·â‰¤Â·)` is antisymmetric, that is, `a â‰¤ b â†’ b â‰¤ a â†’ a = b`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (Â¬ . < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "antisymm",
    "link": null,
    "docstring":
    "An antisymmetric relation `(Â·â‰¤Â·)` satisfies `a â‰¤ b â†’ b â‰¤ a â†’ a = b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬aâœ < bâœ", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬bâœ < aâœ", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ m â‰¤ n â†’ n = m",
     "name": "Nat.le_antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_antisymm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, Â¬n < m â†’ n â‰¥ m",
     "name": "Nat.ge_of_not_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ge_of_not_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬bâœ < aâœ", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, Â¬n < m â†’ n â‰¥ m",
     "name": "Nat.ge_of_not_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ge_of_not_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Â¬aâœ < bâœ", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ âˆ€ (k : Nat), k + n â‰¤ k + m",
     "name": "add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | âŸ¨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + w = m", "name": "hw", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hw",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ© =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + n + w = k + (n + w)", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + (n + w) = k + m", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "     := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± Î² : Type} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring":
    "Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing aâ‚> = <something containing aâ‚‚>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + w = m", "name": "hw", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hw",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + k = m â†’ n â‰¤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + n + w = k + (n + w)", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b c : Î±}, a = b â†’ b = c â†’ a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring":
    "Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you have variables or expressions\n`hâ‚ : a = b` and `hâ‚‚ : b = c`, you can use `hâ‚.trans hâ‚‚ : a = c` as shorthand\nfor `Eq.trans hâ‚ hâ‚‚`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + (n + w) = k + m", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ âˆ€ (k : Nat), n + k â‰¤ m + k",
     "name": "add_le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k â‰¤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k â‰¤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "k + n â‰¤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k â‰¤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "k + n â‰¤ k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "k + n â‰¤ k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k â‰¤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n â‰¤ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ âˆ€ (k : Nat), k + n â‰¤ k + m",
     "name": "Nat.add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k â‰¤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `â€¹tâ€º` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ âˆ€ (k : Nat), k + n < k + m",
     "name": "add_lt_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_lt_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ m â†’ n < m",
     "name": "lt_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ âˆ€ (k : Nat), k + n â‰¤ k + m",
     "name": "Nat.add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ succ n â‰¤ m",
     "name": "succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ âˆ€ (k : Nat), n + k < m + k",
     "name": "add_lt_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_lt_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â–¸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ âˆ€ (k : Nat), k + n < k + m",
     "name": "Nat.add_lt_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_lt_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 1", "name": "zero_lt_one", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ":",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 < succ n",
     "name": "zero_lt_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c d : Nat}, a â‰¤ b â†’ c â‰¤ d â†’ a + c â‰¤ b + d",
     "name": "add_le_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c â‰¤ d", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ âˆ€ (k : Nat), n + k â‰¤ m + k",
     "name": "Nat.add_le_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ âˆ€ (k : Nat), k + n â‰¤ k + m",
     "name": "Nat.add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c â‰¤ d", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c d : Nat}, a < b â†’ c < d â†’ a + c < b + d",
     "name": "add_lt_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_lt_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c < d", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m < k â†’ n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ âˆ€ (k : Nat), n + k < m + k",
     "name": "Nat.add_lt_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_lt_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "hâ‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ âˆ€ (k : Nat), k + n < k + m",
     "name": "Nat.add_lt_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_lt_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c < d", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a + b â‰¤ a + c â†’ b â‰¤ c",
     "name": "le_of_add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b â‰¤ a + c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b â‰¤ a + c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| âŸ¨",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "a + b + d = a + c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ© =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + k = m â†’ n â‰¤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + (b + d) = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + (b + d) = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + (b + d) = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "a + b + d = a + c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + m = n + k â†’ m = k",
     "name": "Nat.add_left_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "a + (b + d) = a + c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a + b â‰¤ c + b â†’ a â‰¤ c",
     "name": "le_of_add_le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_add_le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c + b â†’ a â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c + b â†’ a â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + a â‰¤ c + b â†’ a â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c + b â†’ a â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + a â‰¤ b + c â†’ a â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + a â‰¤ b + c â†’ a â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c + b â†’ a â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a + b â‰¤ a + c â†’ b â‰¤ c",
     "name": "Nat.le_of_add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  "\n\n/-! # Basic theorems for comparing numerals -/\n\ntheorem ctor_eq_zero : Nat.zero = 0 :=\n  rfl\n\nprotected theorem one_ne_zero : 1 â‰  (0 : Nat) :=\n  fun h => Nat.noConfusion h\n\nprotected theorem zero_ne_one : 0 â‰  (1 : Nat) :=\n  fun h => Nat.noConfusion h\n\ntheorem succ_ne_zero (n : Nat) : succ n â‰  0 :=\n  fun h => Nat.noConfusion h\n\n/-! # mul + order -/\n\ntheorem mul_le_mul_left {n m : Nat} (k : Nat) (h : n â‰¤ m) : k * n â‰¤ k * m :=\n  match le.dest h with\n  | âŸ¨l, hlâŸ© =>\n    have : k * n + k * l = k * m := Nat.left_distrib k n l â–¸ hl.symm â–¸ rfl\n    le.intro this\n\ntheorem mul_le_mul_right {n m : Nat} (k : Nat) (h : n â‰¤ m) : n * k â‰¤ m * k :=\n  Nat.mul_comm k m â–¸ Nat.mul_comm k n â–¸ mul_le_mul_left k h\n\nprotected theorem mul_le_mul {nâ‚ mâ‚ nâ‚‚ mâ‚‚ : Nat} (hâ‚ : nâ‚ â‰¤ nâ‚‚) (hâ‚‚ : mâ‚ â‰¤ mâ‚‚) : nâ‚ * mâ‚ â‰¤ nâ‚‚ * mâ‚‚ :=\n  Nat.le_trans (mul_le_mul_right _ hâ‚) (mul_le_mul_left _ hâ‚‚)\n\nprotected theorem mul_lt_mul_of_pos_left {n m k : Nat} (h : n < m) (hk : k > 0) : k * n < k * m :=\n  Nat.lt_of_lt_of_le (Nat.add_lt_add_left hk _) (Nat.mul_succ k n â–¸ Nat.mul_le_mul_left k (succ_le_of_lt h))\n\nprotected theorem mul_lt_mul_of_pos_right {n m k : Nat} (h : n < m) (hk : k > 0) : n * k < m * k :=\n  Nat.mul_comm k m â–¸ Nat.mul_comm k n â–¸ Nat.mul_lt_mul_of_pos_left h hk\n\nprotected theorem mul_pos {n m : Nat} (ha : n > 0) (hb : m > 0) : n * m > 0 :=\n  have h : 0 * m < n * m := Nat.mul_lt_mul_of_pos_right ha hb\n  Nat.zero_mul m â–¸ h\n\nprotected theorem le_of_mul_le_mul_left {a b c : Nat} (h : c * a â‰¤ c * b) (hc : 0 < c) : a â‰¤ b :=\n  Nat.ge_of_not_lt fun hlt : b < a =>\n    have h' : c * b < c * a := Nat.mul_lt_mul_of_pos_left hlt hc\n    absurd h (Nat.not_le_of_gt h')\n\nprotected theorem eq_of_mul_eq_mul_left {m k n : Nat} (hn : 0 < n) (h : n * m = n * k) : m = k :=\n  Nat.le_antisymm (Nat.le_of_mul_le_mul_left (Nat.le_of_eq h) hn)\n                  (Nat.le_of_mul_le_mul_left (Nat.le_of_eq h.symm) hn)\n\ntheorem eq_of_mul_eq_mul_right {n m k : Nat} (hm : 0 < m) (h : n * m = k * m) : n = k := ",
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m * n = k * m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {m k n : Nat}, 0 < n â†’ n * m = n * k â†’ m = k",
     "name": "Nat.eq_of_mul_eq_mul_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_of_mul_eq_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 < m", "name": "hm", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m * n = m * k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  "\n\n/-! # power -/\n\ntheorem pow_succ (n m : Nat) : n^(succ m) = n^m * n :=\n  rfl\n\ntheorem pow_zero (n : Nat) : n^0 = 1 := rfl\n\ntheorem pow_le_pow_of_le_left {n m : Nat} (h : n â‰¤ m) : âˆ€ (i : Nat), n^i â‰¤ m^i\n  | 0      => Nat.le_refl _\n  | succ i => Nat.mul_le_mul (pow_le_pow_of_le_left h i) h\n\ntheorem pow_le_pow_of_le_right {n : Nat} (hx : n > 0) {i : Nat} : âˆ€ {j}, i â‰¤ j â†’ n^i â‰¤ n^j\n  | 0,      h =>\n    have : i = 0 := eq_zero_of_le_zero h\n    this.symm â–¸ Nat.le_refl _\n  | succ j, h =>\n    match le_or_eq_of_le_succ h with\n    | Or.inl h => show n^i â‰¤ n^j * n from\n      have : n^i * 1 â‰¤ n^j * n := Nat.mul_le_mul (pow_le_pow_of_le_right hx h) hx\n      Nat.mul_one (n^i) â–¸ this\n    | Or.inr h =>\n      h.symm â–¸ Nat.le_refl _\n\ntheorem pos_pow_of_pos {n : Nat} (m : Nat) (h : 0 < n) : 0 < n^m :=\n  pow_le_pow_of_le_right h (Nat.zero_le _)\n\n/-! # min/max -/\n\nprotected def min (n m : Nat) : Nat :=\n  if n â‰¤ m then n else m\n\nprotected def max (n m : Nat) : Nat :=\n  if n â‰¤ m then m else n\n\n/-! # Auxiliary theorems for well-founded recursion -/\n\ntheorem not_eq_zero_of_lt (h : b < a) : a â‰  0 := ",
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "b < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"},
     {"type": "b < zero", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero â‰  0",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "nâœ"], "body": "", "_type": "hypothesis"},
     {"type": "b < succ nâœ",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ nâœ â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "b < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "nâœ"], "body": "", "_type": "hypothesis"},
     {"type": "b < succ nâœ",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ nâœ â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b < zero", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < 0",
     "name": "Nat.not_lt_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_lt_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "b < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type":
     "âˆ€ {P : Prop} {v1 v2 : Nat}, v1 = v2 â†’ Nat.noConfusionType P v1 v2",
     "name": "Nat.noConfusion",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.noConfusion",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, m < n â†’ pred n < n",
     "name": "pred_lt'",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_lt'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n : Nat}, n â‰  0 â†’ pred n < n",
     "name": "pred_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {b a : Nat}, b < a â†’ a â‰  0",
     "name": "not_eq_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "not_eq_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n/-! # sub/pred theorems -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a b : Nat), a + b - a = b",
     "name": "add_sub_self_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_self_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + b - zero = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b - a = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (a + b) - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "Nat.succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "Nat.succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b - a = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a b : Nat), a + b - b = a",
     "name": "add_sub_self_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_self_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b + a - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b + a - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b + a - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a b : Nat), a + b - a = b",
     "name": "add_sub_self_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_sub_self_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a i : Nat), a - i â‰¤ succ a - i",
     "name": "sub_le_succ_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_le_succ_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i â‰¤ succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i â‰¤ succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero â‰¤ succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero < succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ n â‰¤ m",
     "name": "Nat.le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero < succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero â‰¤ succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n < succ n",
     "name": "Nat.lt_succ_self",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_succ_self",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i â‰¤ succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i â‰¤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i â‰¤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) â‰¤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i â‰¤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) â‰¤ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "Nat.succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) â‰¤ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) â‰¤ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i â‰¤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), pred n â‰¤ n",
     "name": "Nat.pred_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.pred_le",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {i a : Nat}, i < a â†’ 0 < a - i",
     "name": "zero_lt_sub_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_sub_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i < a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < zero", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < zero - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : Â¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x â‰  x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "i < a â†’ 0 < a - i", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n = m âˆ¨ n < m",
     "name": "Nat.eq_or_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_or_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "i < succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "succ i = succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ i = succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "i = a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "injection",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c tâ‚)`\nand `(c tâ‚‚)` are two terms that are equal then  `tâ‚` and `tâ‚‚` are equal too.\nIf `q` is a proof of a statement of conclusion `tâ‚ = tâ‚‚`, then injection applies\ninjectivity to derive the equality of all arguments of `tâ‚` and `tâ‚‚` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `tâ‚` and `tâ‚‚` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with hâ‚ hâ‚‚` uses the names `hâ‚` and `hâ‚‚` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c tâ‚)`\nand `(c tâ‚‚)` are two terms that are equal then  `tâ‚` and `tâ‚‚` are equal too.\nIf `q` is a proof of a statement of conclusion `tâ‚ = tâ‚‚`, then injection applies\ninjectivity to derive the equality of all arguments of `tâ‚` and `tâ‚‚` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `tâ‚` and `tâ‚‚` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with hâ‚ hâ‚‚` uses the names `hâ‚` and `hâ‚‚` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ i = succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c tâ‚)`\nand `(c tâ‚‚)` are two terms that are equal then  `tâ‚` and `tâ‚‚` are equal too.\nIf `q` is a proof of a statement of conclusion `tâ‚ = tâ‚‚`, then injection applies\ninjectivity to derive the equality of all arguments of `tâ‚` and `tâ‚‚` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `tâ‚` and `tâ‚‚` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with hâ‚ hâ‚‚` uses the names `hâ‚` and `hâ‚‚` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c tâ‚)`\nand `(c tâ‚‚)` are two terms that are equal then  `tâ‚` and `tâ‚‚` are equal too.\nIf `q` is a proof of a statement of conclusion `tâ‚ = tâ‚‚`, then injection applies\ninjectivity to derive the equality of all arguments of `tâ‚` and `tâ‚‚` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `tâ‚` and `tâ‚‚` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with hâ‚ hâ‚‚` uses the names `hâ‚` and `hâ‚‚` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " h",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c tâ‚)`\nand `(c tâ‚‚)` are two terms that are equal then  `tâ‚` and `tâ‚‚` are equal too.\nIf `q` is a proof of a statement of conclusion `tâ‚ = tâ‚‚`, then injection applies\ninjectivity to derive the equality of all arguments of `tâ‚` and `tâ‚‚` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `tâ‚` and `tâ‚‚` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with hâ‚ hâ‚‚` uses the names `hâ‚` and `hâ‚‚` to name the new hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "i = a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "succ i = succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "subst",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "_type": "token"},
   {"typeinfo": {"type": "i = a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "succ i = succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < i + 1 - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â†",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), n + 1 = succ n",
     "name": "Nat.add_one",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < 1",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (a b : Nat), a + b - a = b",
     "name": "Nat.add_sub_self_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_self_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < 1",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i â†’ 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < 1",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "succ i = succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "decide",
    "link": null,
    "docstring":
    "`decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Because this uses kernel\ncomputation to evaluate the term, it may not work in the presence of definitions\nby well founded recursion, since this requires reducing proofs.\n```\nexample : 2 + 2 â‰  5 := by decide\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "succ i < succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ i < succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "succ i < succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < a - i",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "i < a â†’ 0 < a - i", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n < succ m â†’ n < m",
     "name": "Nat.lt_of_succ_lt_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_succ_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ i < succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a â†’ 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["hâœ"], "body": "", "_type": "hypothesis"},
     {"type": "succ i < succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n < m â†’ m â‰¤ k â†’ n < k",
     "name": "Nat.lt_of_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 < a - i", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a i : Nat), a - i â‰¤ succ a - i",
     "name": "Nat.sub_le_succ_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_le_succ_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (a i : Nat), i < a â†’ a - (i + 1) < a - i",
     "name": "sub_succ_lt_self",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_succ_lt_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i < a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ (i + 0) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "Nat.add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "a",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n : Nat}, n â‰  0 â†’ pred n < n",
     "name": "Nat.pred_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.pred_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "a.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "?a.bâœ < a - i",
    "_type": "goal"},
   {"name": "a.b",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {b a : Nat}, b < a â†’ a â‰  0",
     "name": "Nat.not_eq_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_eq_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "a.h.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "i < a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {i a : Nat}, i < a â†’ 0 < a - i",
     "name": "Nat.zero_lt_sub_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_lt_sub_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `â€¹tâ€º` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a : Nat}, a â‰  0 â†’ succ (pred a) = a",
     "name": "succ_pred",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a â‰  0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred a) = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred a) = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "zero â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred zero) = zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : Â¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x â‰  x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰  0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred a) = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["nâœ"], "body": "", "_type": "hypothesis"},
     {"type": "nâœ â‰  0 â†’ succ (pred nâœ) = nâœ",
      "names": ["n_ihâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ nâœ â‰  0",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (pred (succ nâœ)) = succ nâœ",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl` tries to close the current goal using reflexivity.\nThis is supposed to be an extensible tactic and users can add their own support\nfor new reflexive relations.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a < b â†’ b - a â‰  0",
     "name": "sub_ne_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_ne_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", _ => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"},
     {"type": "0 < succ b",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ b - 0 â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ a < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ Â¬a â†’ b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring":
    "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : Â¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ a < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < 0",
     "name": "Nat.not_lt_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_lt_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ a < succ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ b - succ a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ b - succ a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b - a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "Nat.succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b - a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b - a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ b - succ a â‰  0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a < b â†’ b - a â‰  0",
     "name": "sub_ne_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_ne_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n < succ m â†’ n < m",
     "name": "Nat.lt_of_succ_lt_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_succ_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ a < succ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a â‰¤ b â†’ a + (b - a) = b",
     "name": "add_sub_of_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"},
     {"type": "zero â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + (b - zero) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "a â‰¤ b â†’ a + (b - a) = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0",
      "names": ["hne"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b - a â‰  0", "name": "hne", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hne",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰  ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a < b â†’ b - a â‰  0",
     "name": "Nat.sub_ne_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_ne_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ a â‰¤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, succ n â‰¤ m â†’ n â‰¤ m",
     "name": "Nat.le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ a â‰¤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + pred (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (a + pred (b - a)) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "Nat.succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + succ (pred (b - a)) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "Nat.add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ {a : Nat}, a â‰  0 â†’ succ (pred a) = a",
     "name": "Nat.succ_pred",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b - a â‰  0", "name": "hne", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hne",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b â†’ a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a â‰¤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a â‰  0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "a â‰¤ b â†’ a + (b - a) = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, m â‰¤ n â†’ n - m + m = n",
     "name": "sub_add_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_add_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¤ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m â‰¤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m + m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m â‰¤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m + m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m â‰¤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m + (n - m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m â‰¤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m + m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m â‰¤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a â‰¤ b â†’ a + (b - a) = b",
     "name": "Nat.add_sub_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m â‰¤ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n k m : Nat), n + k - (m + k) = n - m",
     "name": "add_sub_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + zero - (m + zero) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + k - (m + k) = n - m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + succ k - (m + succ k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + k - (m + k) = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + k - (m + k) = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (k n m : Nat), k + n - (k + m) = n - m",
     "name": "add_sub_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n k m : Nat), n + k - (m + k) = n - m",
     "name": "Nat.add_sub_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m - m = n",
     "name": "add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "suffices",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - (0 + m) = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + m - (0 + m) = n", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - (0 + m) = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `â€¹tâ€º` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (0 + m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (0 + m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - 0 = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n k m : Nat), n + k - (m + k) = n - m",
     "name": "Nat.add_sub_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (0 + m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), n - 0 = n",
     "name": "Nat.sub_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_zero",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m - n = m",
     "name": "add_sub_cancel_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_cancel_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "from",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (n + 0) = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (n + 0) = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m - 0 = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (k n m : Nat), k + n - (k + m) = n - m",
     "name": "Nat.add_sub_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (n + 0) = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), n - 0 = n",
     "name": "Nat.sub_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_zero",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {m k : Nat}, k â‰¤ m â†’ âˆ€ (n : Nat), n + m - k = n + (m - k)",
     "name": "add_sub_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "k â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "wâœ"], "body": "", "_type": "hypothesis"},
     {"type": "k + wâœ = m",
      "names": ["hâœ"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "Nat.le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "k â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rename_i",
    "link": null,
    "docstring":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "l", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "l",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "_type": "token"},
   {"typeinfo": {"type": "k + l = m", "name": "hl", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hl",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (k + l) - k = n + (k + l - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "k + l = m", "name": "hl", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (k + l) - k = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m - n = m",
     "name": "Nat.add_sub_cancel_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (l + k) - k = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + l + k - k = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + l = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m - m = n",
     "name": "Nat.add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, b â‰¤ a â†’ a - b = c â†’ a = c + b",
     "name": "eq_add_of_sub_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_add_of_sub_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ a", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a - b = c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = a - b + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": {"type": "a - b = c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ {n m : Nat}, m â‰¤ n â†’ n - m + m = n",
     "name": "Nat.sub_add_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_add_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ a", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a = c + b â†’ a - b = c",
     "name": "sub_eq_of_eq_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_eq_of_eq_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "c + b - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": {"type": "a = c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "c = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m - m = n",
     "name": "Nat.add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a - b â‰¤ c â†’ a â‰¤ c + b",
     "name": "le_add_of_sub_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_of_sub_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a - b â‰¤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a - b â‰¤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (m n : Nat), m â‰¤ n âˆ¨ n â‰¤ m",
     "name": "Nat.le_total",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_total",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Exists fun k => a - b + k = c",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| _, ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n â‰¤ m + n",
     "name": "Nat.le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..)",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| âŸ¨",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a - b + d = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ©, ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + k = m â†’ n â‰¤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + (a - b) = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {m k : Nat}, k â‰¤ m â†’ âˆ€ (n : Nat), n + m - k = n + (m - k)",
     "name": "Nat.add_sub_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "d + (a - b) = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "d + a = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, b â‰¤ a â†’ a - b = c â†’ a = c + b",
     "name": "Nat.eq_add_of_sub_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_add_of_sub_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n â‰¤ m + n",
     "name": "Nat.le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..)) ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "d + a - b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "d + a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "c + b = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": {"type": "d + a = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 - n = 0", "name": "zero_sub", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses": [],
    "conclusion": "0 - zero = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl` tries to close the current goal using reflexivity.\nThis is supposed to be an extensible tactic and users can add their own support\nfor new reflexive relations.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "0 - n = 0", "names": ["ih"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 - n = 0", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 - n = 0", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - (n + m) = 0",
     "name": "sub_self_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_self_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + 0 - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - (",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + 0 - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (k n m : Nat), k + n - (k + m) = n - m",
     "name": "Nat.add_sub_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + 0 - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 - n = 0",
     "name": "Nat.zero_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_sub",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n - m = 0",
     "name": "sub_eq_zero_of_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_eq_zero_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "n â‰¤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| âŸ¨",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ© =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - (n + k) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n â‰¤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - (n + m) = 0",
     "name": "Nat.sub_self_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_self_add",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a â‰¤ c + b â†’ a - b â‰¤ c",
     "name": "sub_le_of_le_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_le_of_le_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (m n : Nat), m â‰¤ n âˆ¨ n â‰¤ m",
     "name": "Nat.le_total",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_total",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Exists fun k => a + k = c + b",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| _, ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Exists fun k => a + k = c + b",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Exists fun k => a + k = c + b",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n - m = 0",
     "name": "Nat.sub_eq_zero_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_zero_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Exists fun k => a + k = c + b",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Exists fun k => a + k = c + b",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), 0 â‰¤ n", "name": "Nat.zero_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_le",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| âŸ¨",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ©, ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + k = m â†’ n â‰¤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d - b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a = c + b â†’ a - b = c",
     "name": "Nat.sub_eq_of_eq_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_of_eq_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "d + (a - b) = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "d + a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "â† ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {m k : Nat}, k â‰¤ m â†’ âˆ€ (n : Nat), n + m - k = n + (m - k)",
     "name": "Nat.add_sub_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a â‰¤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d - b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, b â‰¤ c â†’ a â‰¤ c - b â†’ a + b â‰¤ c",
     "name": "add_le_of_le_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_of_le_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ c", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ c - b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a â‰¤ c - b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| âŸ¨",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c - b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ© =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + k = m â†’ n â‰¤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = a + d + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, b â‰¤ a â†’ a - b = c â†’ a = c + b",
     "name": "Nat.eq_add_of_sub_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_add_of_sub_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ c", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c - b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = a + d + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a â‰¤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "Nat.add_left_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a + b â‰¤ c â†’ a â‰¤ c - b",
     "name": "le_sub_of_add_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_sub_of_add_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b â‰¤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b â‰¤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| âŸ¨",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b + d = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "âŸ© =>",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m k : Nat}, n + k = m â†’ n â‰¤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d + b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d + b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [â† ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b + d = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "Nat.add_left_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hdâœÂ¹"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + d + b = c",
      "names": ["hdâœ"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "c - b = a + d",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "c - b = a + d", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a = c + b â†’ a - b = c",
     "name": "Nat.sub_eq_of_eq_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_of_eq_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d + b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b â‰¤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a â‰¤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "c - b = a + d", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a < c - b â†’ a + b < c",
     "name": "add_lt_of_lt_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_lt_of_lt_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < c - b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b < c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b < c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ c", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Â¬c < b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, Â¬n < m â†’ n â‰¥ m",
     "name": "Nat.ge_of_not_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ge_of_not_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "c < b", "names": ["hgt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "c < b", "name": "hgt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hgt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "c < b", "names": ["hgt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a < 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), Â¬n < 0",
     "name": "Nat.not_lt_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_lt_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "c < b", "names": ["hgt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a < 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < 0", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "c < b", "names": ["hgt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a < 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n - m = 0",
     "name": "Nat.sub_eq_zero_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_zero_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ n â‰¤ m",
     "name": "Nat.le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "c < b", "name": "hgt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hgt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < 0", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "c < b", "names": ["hgt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a < 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < 0", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "c < b", "names": ["hgt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a < 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a < c - b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b < c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "succ a + b â‰¤ c",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b < c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, b â‰¤ c â†’ a â‰¤ c - b â†’ a + b â‰¤ c",
     "name": "add_le_of_le_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_le_of_le_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b â‰¤ c", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a < c - b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b < c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b â‰¤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "succ (a + b) â‰¤ c",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b < c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "Nat.succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ a + b â‰¤ c", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a < c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b < c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ (a + b) â‰¤ c", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a + b < c â†’ a < c - b",
     "name": "lt_sub_of_add_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_sub_of_add_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b < c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b < c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b < c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (a + b) â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n + m = succ (n + m)",
     "name": "Nat.succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b < c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (a + b) â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b < c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + b â‰¤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b < c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Nat}, a + b â‰¤ c â†’ a â‰¤ c - b",
     "name": "le_sub_of_add_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_sub_of_add_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ a + b â‰¤ c", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "pred 0 = 0", "name": "pred_zero", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n : Nat), pred (succ n) = n",
     "name": "pred_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a : Î±}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "âˆ€ {motive : Nat â†’ Prop} (x y : Nat), (y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k) â†’ (x < y â†’ motive 0) â†’ motive (x - y)",
     "name": "sub.elim",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub.elim",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
     "name": "hâ‚",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â‰¤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "x < y â†’ motive 0", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " â†’ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y âˆ¨ x â‰¥ y",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n < m âˆ¨ n â‰¥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b", "name": "inl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n â‰¤ m â†’ n - m = 0",
     "name": "Nat.sub_eq_zero_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_zero_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {n m : Nat}, n < m â†’ n â‰¤ m",
     "name": "Nat.le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y â†’ motive 0", "name": "hâ‚‚", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y âˆ¨ x â‰¥ y",
      "names": ["xâœ"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inr",
    "hypotheses":
    [{"type": "Nat â†’ Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
      "names": ["hâ‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y â†’ motive 0",
      "names": ["hâ‚‚"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x â‰¥ y", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b", "name": "inr", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x â‰¥ y", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "y â‰¤ x â†’ âˆ€ (k : Nat), x = y + k â†’ motive k",
     "name": "hâ‚",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hâ‚",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x â‰¥ y", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Nat}, a â‰¤ b â†’ a + (b - a) = b",
     "name": "Nat.add_sub_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x â‰¥ y", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {Î± : Type} {a b : Î±}, a = b â†’ b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), pred n * m = n * m - m",
     "name": "mul_pred_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_pred_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred n * m = n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred n * m = n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred zero * m = zero * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred n * m = n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil => tacâ‚ | cons a as' => tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n : Nat), pred (succ n) = n",
     "name": "Nat.pred_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.pred_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m = n * m + m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m = n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + m - m = n",
     "name": "Nat.add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * pred m = n * m - n",
     "name": "mul_pred_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_pred_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring":
    "The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred m * n = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m * n - n = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), pred n * m = n * m - m",
     "name": "mul_pred_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_pred_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m - n = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n - m - k = n - (m + k)",
     "name": "sub_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - k = n - (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - k = n - (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m - zero = n - (m + zero)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - k = n - (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n - m - k = n - (m + k)", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - succ (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n + succ m = succ (n + m)",
     "name": "Nat.add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - m - k) = n - succ (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - m - k) = pred (n - (m + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - (m + k)) = pred (n - (m + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "n - m - k = n - (m + k)", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), (n - m) * k = n * k - m * k",
     "name": "mul_sub_right_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_sub_right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k = n * k - m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k = n * k - m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(n - zero) * k = n * k - zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.\n  If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k = n * k - m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tacâ‚ | succ x' ih => tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat â†’ Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring":
    "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "(n - m) * k = n * k - m * k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k - k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), pred n * m = n * m - m",
     "name": "Nat.mul_pred_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_pred_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * k - m * k - k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "(n - m) * k = n * k - m * k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * k - m * k - k = n * k - (m * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * k - (m * k + k) = n * k - (m * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n - m - k = n - (m + k)",
     "name": "Nat.sub_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_sub",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "done",
    "link": null,
    "docstring": "`done` succeeds iff there are no remaining goals. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ (n m k : Nat), n * (m - k) = n * m - n * k",
     "name": "mul_sub_left_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_sub_left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(m - k) * n = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m * n - k * n = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m k : Nat), (n - m) * k = n * k - m * k",
     "name": "Nat.mul_sub_right_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_sub_right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m - k * n = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m - k * n = n * m - k * n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "âˆ€ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  "\n\n/-! # Helper normalization theorems -/\n\ntheorem not_le_eq (a b : Nat) : (Â¬ (a â‰¤ b)) = (b + 1 â‰¤ a) :=\n  propext <| Iff.intro (fun h => Nat.gt_of_not_le h) (fun h => Nat.not_le_of_gt h)\n\ntheorem not_ge_eq (a b : Nat) : (Â¬ (a â‰¥ b)) = (a + 1 â‰¤ b) :=\n  not_le_eq b a\n\ntheorem not_lt_eq (a b : Nat) : (Â¬ (a < b)) = (b â‰¤ a) :=\n  propext <| Iff.intro (fun h => have h := Nat.succ_le_of_lt (Nat.gt_of_not_le h); Nat.le_of_succ_le_succ h) (fun h => Nat.not_le_of_gt (Nat.succ_le_succ h))\n\ntheorem not_gt_eq (a b : Nat) : (Â¬ (a > b)) = (a â‰¤ b) :=\n  not_lt_eq b a\n\nend Nat\n\nnamespace Prod\n\n@[inline] def foldI {Î± : Type u} (f : Nat â†’ Î± â†’ Î±) (i : Nat Ã— Nat) (a : Î±) : Î± :=\n  Nat.foldAux f i.2 (i.2 - i.1) a\n\n@[inline] def anyI (f : Nat â†’ Bool) (i : Nat Ã— Nat) : Bool :=\n  Nat.anyAux f i.2 (i.2 - i.1)\n\n@[inline] def allI (f : Nat â†’ Bool) (i : Nat Ã— Nat) : Bool :=\n  Nat.anyAux (fun a => !f a) i.2 (i.2 - i.1)\n\nend Prod\n",
  "_type": "text"}]