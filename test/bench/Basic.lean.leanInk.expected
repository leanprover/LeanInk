[{"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw":
    "/-\nCopyright (c) 2014 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn, Leonardo de Moura\n-/\nprelude\nimport Init.SimpLemmas\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "universe",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " u\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "namespace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " Nat\n\n@[specialize] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat → Nat → α → α",
     "name": "foldAux",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "foldAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat → Nat → α → α",
     "name": "foldAux",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "foldAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat → α → α",
     "name": "fold",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "fold",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "init", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "init",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat → Nat → α → α",
     "name": "foldAux",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "foldAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "init", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "init",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat → α → α",
     "name": "foldRev",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "foldRev",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "init", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "init",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "let",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rec",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @[specialize] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat → α → α",
     "name": "loop",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "loop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "loop", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "loop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "loop", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "loop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "init", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "init",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[specialize] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Nat → Bool",
     "name": "anyAux",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "anyAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "false", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "false",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) || ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Nat → Bool",
     "name": "anyAux",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "anyAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "\n\n/- `any f n = true` iff there is `i in [0, n-1]` s.t. `f i = true` -/\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Bool", "name": "any", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "any",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Nat → Bool",
     "name": "anyAux",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "anyAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Bool", "name": "all", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "all",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  !",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Bool", "name": "any", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "any",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => !",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (α → α) → Nat → α → α",
     "name": "repeat",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "repeat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "let",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rec",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @[specialize] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (α → α) → Nat → α → α",
     "name": "loop",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "loop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "loop", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "loop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "loop", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "loop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Bool", "name": "blt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "blt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Bool", "name": "ble", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "ble",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- Helper \"packing\" theorems -/\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "zero = 0", "name": "zero_eq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "Nat.zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, Nat.add x y = x + y",
     "name": "add_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "Nat.add", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, Nat.mul x y = x * y",
     "name": "mul_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "Nat.mul", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, Nat.sub x y = x - y",
     "name": "sub_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "Nat.sub", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, Nat.lt x y = (x < y)",
     "name": "lt_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Prop", "name": "Nat.lt", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, Nat.le x y = (x ≤ y)",
     "name": "le_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Prop", "name": "Nat.le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- Helper Bool relation theorems -/\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a : Nat), beq a a = true",
     "name": "beq_refl",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "beq_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Bool", "name": "Nat.beq", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.beq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "beq a a = true",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Bool", "name": "Nat.beq", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.beq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "beq a a = true",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "beq a a = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "beq a a = true", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "beq a a = true", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, (beq x y = true) = (x = y)",
     "name": "beq_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "beq_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Bool", "name": "Nat.beq", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.beq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, beq n m = true → n = m",
     "name": "Nat.eq_of_beq_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_of_beq_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "x = y", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "x = y", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a : Nat), beq a a = true",
     "name": "Nat.beq_refl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.beq_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "))\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, (ble x y = true) = (x ≤ y)",
     "name": "ble_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ble_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Bool", "name": "Nat.ble", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ble",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, ble n m = true → n ≤ m",
     "name": "Nat.le_of_ble_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_ble_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ble n m = true",
     "name": "Nat.ble_eq_true_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ble_eq_true_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {x y : Nat}, (blt x y = true) = (x < y)",
     "name": "blt_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "blt_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Bool", "name": "Nat.blt", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.blt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, ble n m = true → n ≤ m",
     "name": "Nat.le_of_ble_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_ble_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ble n m = true",
     "name": "Nat.ble_eq_true_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ble_eq_true_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "LawfulBEq Nat", "name": "instance", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(α : Type) → [inst : BEq α] → Prop",
     "name": "LawfulBEq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LawfulBEq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  eq_of_beq _ _ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(x✝¹ == x✝) = true", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, beq n m = true → n = m",
     "name": "Nat.eq_of_beq_eq_true",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_of_beq_eq_true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(x✝¹ == x✝) = true", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  rfl ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == a) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type ?u.2567} → [self : BEq α] → α → α → Bool",
     "name": "BEq.beq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "BEq.beq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), ((a == b) = true) = (a = b)",
     "name": "beq_eq_true_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "beq_eq_true_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " == ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {α : Type} [inst : BEq α] [inst_1 : LawfulBEq α] {a b : α}, (a == b) = true → a = b",
     "name": "eq_of_beq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "eq_of_beq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a = b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == b) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == a) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "subst",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. ",
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == a) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a = b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(a == b) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {α : Type} [inst : BEq α] [self : LawfulBEq α] (a : α), (a == a) = true",
     "name": "LawfulBEq.rfl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LawfulBEq.rfl",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ")\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), ((!a == b) = true) = ¬a = b",
     "name": "not_beq_eq_true_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_beq_eq_true_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ((!(",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " == ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ¬(",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(!a == b) = true", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == b) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = b", "names": ["h₂"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == a) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "subst",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. ",
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == a) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == b) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = b", "names": ["h₂"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == a) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type":
     "∀ {α : Type} [inst : BEq α] [self : LawfulBEq α] (a : α), (a == a) = true",
     "name": "LawfulBEq.rfl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LawfulBEq.rfl",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "(!a == a) = true", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "(!true) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "(!a == b) = true",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = b", "names": ["h₂"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ¬ ((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " == ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Bool", "name": "true", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "true",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(a == b) = true", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {α : Type} [inst : BEq α] [inst_1 : LawfulBEq α] {a b : α}, (a == b) = true → a = b",
     "name": "eq_of_beq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "eq_of_beq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "(a == b) = true", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "¬a = b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "¬(a == b) = true",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(!a == b) = true",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "¬(a == b) = true", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n/- Nat.add theorems -/\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 + n = n", "name": "zero_add", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | n+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α β : Type} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", m+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α β : Type} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n + 1 = succ n",
     "name": "add_one",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), succ n = n + 1",
     "name": "succ_eq_add_one",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_eq_add_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "add_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "Eq.symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Eq.symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", m+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (n + m) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m = m + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α β : Type} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m = m + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (n + m) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ (n + m) = succ (m + n)",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ (n + m) = succ (m + n)",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ (n + m) = succ (m + n)",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = succ (m + n)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (m + 1) = m + 1 + n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ (n + m) = succ (m + n)",
     "name": "this",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "add_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α β : Type} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "add_left_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m + n + k = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m + (n + k) = m + (n + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + k + m",
     "name": "add_right_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_right_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (m + k) = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + (k + m) = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m + k = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k + m = n + k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + m = n + k → m = k",
     "name": "add_left_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_left_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + m = zero + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + m = zero + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intros",
    "link": null,
    "docstring":
    "`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous) hypotheses until goal is not of a function type. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + m = zero + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k → m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n + m = succ n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + m = n + k → m = k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k → m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k → m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m = n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k → m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n + m = succ n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k → m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + m = n + k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k → m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["m", "k", "n"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = n + k → m = k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n + m = succ n + k → m = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + m = n + k → m = k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + m = n + k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + m = k + m → n = k",
     "name": "add_right_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_right_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + m = k + m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = m + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = m + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "m + n = m + k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + m = k + m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + m = k + m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + m = n + k → m = k",
     "name": "Nat.add_left_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m + n = m + k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- Nat.mul theorems -/\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n * 0 = 0", "name": "mul_zero", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 * n = 0", "name": "zero_mul", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 * n = 0",
     "name": "Nat.zero_mul",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.zero_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * m = n * m + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * m = n * m + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * zero = n * zero + zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * m = n * m + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ n * m = n * m + m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * m + succ n = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (succ n * m + n) = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + m + n) = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "succ n * m = n * m + m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + m + n) = n * m + n + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + m + n) = succ (n * m + n + m)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n * succ m = n * succ m + succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n * m = n * m + m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (n * m + n + m) = succ (n * m + n + m)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + k + m",
     "name": "Nat.add_right_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_right_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "mul_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 * n = 0",
     "name": "Nat.zero_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n * 0 = 0",
     "name": "Nat.mul_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * succ m = n * m + n",
     "name": "mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n * 1 = n", "name": "mul_one", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 1 * n = n", "name": "one_mul", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "one_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n * 1 = n",
     "name": "Nat.mul_one",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "left_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m + k) = n * m + n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m + k) = n * m + n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "generalizing",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero * (m + k) = zero * m + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero      => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero * (m + k) = zero * m + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "repeat",
    "link": null,
    "docstring":
    "`repeat tac` applies `tac` to main goal. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`repeat tac` applies `tac` to main goal. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0 + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = zero * m + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), 0 * n = 0",
     "name": "Nat.zero_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_mul",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0 + zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m + k) = n * m + n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
     "name": "ih",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
     "name": "ih",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + n * k + (m + k) = n * m + m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + (m + (n * k + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "*",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + (m + (n * k + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m + (n * k + (m + k)) = n * m + (m + (n * k + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ.h",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * k + (m + k) = m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α β : Type} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ.h",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * k + (m + k) = m + (n * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "∀ (m k : Nat), n * (m + k) = n * m + n * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n * (m + k) = succ n * m + succ n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "Nat.add_left_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), (n + m) * k = n * k + m * k",
     "name": "right_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(n + m) * k = k * (n + m)", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")     := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k * (n + m) = k * n + k * m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k * n + k * m = n * k + k * m",
     "name": "h₃",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₃",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * k + k * m = n * k + m * k",
     "name": "h₄",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₄",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(n + m) * k = k * (n + m)", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k * (n + m) = k * n + k * m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k * n + k * m = n * k + k * m",
     "name": "h₃",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₃",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * k + k * m = n * k + m * k",
     "name": "h₄",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₄",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "mul_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), (n + m) * k = n * k + m * k",
     "name": "add_mul",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), (n + m) * k = n * k + m * k",
     "name": "Nat.right_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "mul_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * succ k = n * m * (k + 1)",
     "name": "h₁",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")              := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
     "name": "h₂",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "     := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * k + n * m * 1 = n * m * k + n * m",
     "name": "h₃",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₃",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * succ k = n * m * (k + 1)",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * k + n * m * 1 = n * m * k + n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * succ k = n * m * (k + 1)",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * k + n * m * 1 = n * m * k + n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * succ k = n * m * (k + 1)",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * k + n * m = n * m * k + n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), n * 1 = n",
     "name": "Nat.mul_one",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "*",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * k + n * m = n * (m * k) + n * m",
     "name": "h₄",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₄",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * succ k = n * m * (k + 1)",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * k + n * m * 1 = n * m * k + n * m",
      "names": ["h₃"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * k + n * m = n * (m * k) + n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * succ k = n * m * (k + 1)",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * k + n * m * 1 = n * m * k + n * m",
      "names": ["h₃"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * k + n * m = n * (m * k) + n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * succ k = n * m * (k + 1)",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n * m * k + n * m * 1 = n * m * k + n * m",
      "names": ["h₃"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) + n * m = n * (m * k) + n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "Nat.mul_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * (m * k) + n * m = n * (m * k + m)",
     "name": "h₅",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₅",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")       := (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "*",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * (m * k + m) = n * (m * succ k)",
     "name": "h₆",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₆",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")            := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * succ m = n * m + n",
     "name": "Nat.mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ((((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * succ k = n * m * (k + 1)",
     "name": "h₁",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * (k + 1) = n * m * k + n * m * 1",
     "name": "h₂",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * k + n * m * 1 = n * m * k + n * m",
     "name": "h₃",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₃",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * m * k + n * m = n * (m * k) + n * m",
     "name": "h₄",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₄",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * (m * k) + n * m = n * (m * k + m)",
     "name": "h₅",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₅",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n * (m * k + m) = n * (m * succ k)",
     "name": "h₆",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₆",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m * k) = m * (n * k)",
     "name": "mul_left_comm",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m * k = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "Nat.mul_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m * n * k = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m * (n * k) = m * (n * k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n * m * k = n * (m * k)",
     "name": "Nat.mul_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- Inequalities -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "attribute",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → succ n < succ m",
     "name": "succ_lt_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → succ n ≤ succ m",
     "name": "succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n < succ m",
     "name": "lt_succ_of_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_succ_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → succ n ≤ succ m",
     "name": "succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n - 0 = n", "name": "sub_zero", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ_eq_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_sub_succ_eq_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ zero = n - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero      => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "succ n - succ m = n - m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n - succ (succ m) = n - succ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ n - succ m = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α β : Type} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "succ n - succ m = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), pred n ≤ n", "name": "pred_le", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, Nat.le n n",
     "name": "Nat.le.refl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le.refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ succ n", "name": "le_succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n ≠ 0 → pred n < n",
     "name": "pred_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "zero ≠ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "zero ≠ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≠ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n < succ m",
     "name": "lt_succ_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt_succ_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n - m ≤ n", "name": "sub_le", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m ≤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m ≤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - zero ≤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero      => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m ≤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n - m ≤ n", "names": ["ih"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - succ m ≤ n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n - m ≤ n", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), pred n ≤ n", "name": "pred_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n - m ≤ n", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, 0 < n → 0 < m → n - m < n",
     "name": "sub_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h1", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < m", "name": "h2", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h1", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), ¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | n+1, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < n + 1", "name": "h1", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h2", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h2", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), ¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | n+1, m+1, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < n + 1", "name": "h1", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < m + 1", "name": "h2", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "Eq.symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Eq.symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ_eq_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ_eq_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ▸\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "from",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n < succ m",
     "name": "lt_succ_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt_succ_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n - m ≤ n", "name": "sub_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "sub_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "sub_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ_eq_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ_eq_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n - n = 0", "name": "sub_self", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "        => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "", "hypotheses": [], "conclusion": "0 - 0 = 0", "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "", "hypotheses": [], "conclusion": "0 - 0 = 0", "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "", "hypotheses": [], "conclusion": "0 = 0", "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), n - 0 = n",
     "name": "Nat.sub_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_zero",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ n - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), n - n = 0",
     "name": "Nat.sub_self",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat.sub_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m ≤ k → n < k",
     "name": "lt_of_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m = k → n < k",
     "name": "lt_of_lt_of_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_lt_of_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = k", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = k", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun a a_1 => a < a_1) (fun a a_1 => a < a_1) fun a a_1 => a < a_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{α β γ : Type} → (α → β → Prop) → (β → γ → Prop) → outParam (α → γ → Prop) → Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring": "Transitive chaining of proofs, used e.g. by `calc`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  trans := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m < k → n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun a a_1 => a ≤ a_1) (fun a a_1 => a ≤ a_1) fun a a_1 => a ≤ a_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{α β γ : Type} → (α → β → Prop) → (β → γ → Prop) → outParam (α → γ → Prop) → Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring": "Transitive chaining of proofs, used e.g. by `calc`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. ≤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. ≤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. ≤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  trans := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun a a_1 => a < a_1) (fun a a_1 => a ≤ a_1) fun a a_1 => a < a_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{α β γ : Type} → (α → β → Prop) → (β → γ → Prop) → outParam (α → γ → Prop) → Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring": "Transitive chaining of proofs, used e.g. by `calc`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. ≤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  trans := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m ≤ k → n < k",
     "name": "Nat.lt_of_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "Trans (fun a a_1 => a ≤ a_1) (fun a a_1 => a < a_1) fun a a_1 => a < a_1",
     "name": "instance",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{α β γ : Type} → (α → β → Prop) → (β → γ → Prop) → outParam (α → γ → Prop) → Type",
     "name": "Trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Trans",
    "link": null,
    "docstring": "Transitive chaining of proofs, used e.g. by `calc`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (. ≤ . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (. < . : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  trans := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m < k → n < k",
     "name": "Nat.lt_of_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n = m → n ≤ m",
     "name": "le_of_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ m → n ≤ m",
     "name": "le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ succ n", "name": "le_succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → n ≤ m",
     "name": "le_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ m → n ≤ m",
     "name": "le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → n < succ m",
     "name": "lt.step",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt.step",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n ≤ succ m",
     "name": "le_step",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_step",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n = 0 ∨ n > 0",
     "name": "eq_zero_or_pos",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_zero_or_pos",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∨ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | n+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 < succ n",
     "name": "succ_pos",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_pos",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n < succ n", "name": "lt.base", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt.base",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n < succ n",
     "name": "lt_succ_self",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_succ_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n < succ n", "name": "lt.base", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt.base",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (m n : Nat), m ≤ n ∨ n ≤ m",
     "name": "le_total",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_total",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∨ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n < m ∨ n ≥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → n ≤ m",
     "name": "Nat.le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≥ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≥ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m n : Nat}, m ≤ n → m ≠ n → m < n",
     "name": "lt_of_le_and_ne",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_le_and_ne",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≤ n", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≠ n", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n = m ∨ n < m",
     "name": "Nat.eq_or_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_or_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≤ n", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≠ n", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n ≤ 0 → n = 0",
     "name": "eq_zero_of_le_zero",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_zero_of_le_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → m ≤ n → n = m",
     "name": "Nat.le_antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_antisymm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 ≤ n", "name": "zero_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n < m → n < m",
     "name": "lt_of_succ_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_succ_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ m → n ≤ m",
     "name": "le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n < succ m → n < m",
     "name": "lt_of_succ_lt_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_succ_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ succ m → n ≤ m",
     "name": "le_of_succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ m → n < m",
     "name": "lt_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "lt_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → succ n ≤ m",
     "name": "succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Nat}, a < b → 0 < b",
     "name": "zero_lt_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < x✝", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < x✝", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | a+1, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + 1 < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m < k → n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n < succ n",
     "name": "Nat.lt_succ_self",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_succ_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + 1 < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Nat}, a < b → 0 < b",
     "name": "zero_lt_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m n : Nat}, m ≤ succ n → m ≤ n ∨ m = succ n",
     "name": "le_or_eq_or_le_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_or_eq_or_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≤ succ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∨ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {p q : Prop} [dec : Decidable p], (p → q) → (¬p → q) → q",
     "name": "Decidable.byCases",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Decidable.byCases",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m = succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≠ succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") =>\n       ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m n : Nat}, m ≤ n → m ≠ n → m < n",
     "name": "Nat.lt_of_le_and_ne",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_le_and_ne",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≤ succ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≠ succ n", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n       ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → succ n ≤ m",
     "name": "succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < succ n", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n       ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ succ m → n ≤ m",
     "name": "le_of_succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_of_succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "succ m ≤ succ n", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "))\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n k : Nat), n ≤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "   => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", k+1 => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n ≤ succ m",
     "name": "le_succ_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_succ_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n k : Nat), n ≤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n ≤ m + n",
     "name": "le_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "): ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n k : Nat), n ≤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → (α → Prop) → Prop",
     "name": "Exists",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Exists",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "zero ≤ zero", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "zero ≤ succ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ zero", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ zero", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), succ n ≤ 0 → False",
     "name": "not_succ_le_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "not_succ_le_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ succ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ succ m → n ≤ m",
     "name": "Nat.le_of_succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ succ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → (α → Prop) → Prop",
     "name": "Exists",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Exists",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "dest",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "this", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Exists fun k => n + k = m", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n ≤ succ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩ => ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "from",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ((",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n + m = succ (n + m)",
     "name": "succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")⟩\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n k : Nat), n ≤ n + k",
     "name": "le_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n > m → ¬n ≤ m",
     "name": "not_le_of_gt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_le_of_gt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n < m ∨ n ≥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m < k → n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), ¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≥ m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "Heq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Heq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → m ≤ n → n = m",
     "name": "Nat.le_antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_antisymm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≥ m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (@",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {α : Type} {motive : α → Prop} {a b : α}, a = b → motive a → motive b",
     "name": "Eq.subst",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Eq.subst",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Prop", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n = m", "name": "Heq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Heq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), ¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, ¬n ≤ m → n > m",
     "name": "gt_of_not_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "gt_of_not_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n < m ∨ n ≥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≥ n", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≥ n", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, ¬n < m → n ≥ m",
     "name": "ge_of_not_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ge_of_not_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≥ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n < m ∨ n ≥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≥ m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≥ m", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (k : Nat), k + n ≤ k + m",
     "name": "add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + w = m", "name": "hw", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hw",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩ =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + n + w = k + (n + w)", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + (n + w) = k + m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "w", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "w",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "     := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α β : Type} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
     "name": "congrArg",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "congrArg",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + w = m", "name": "hw", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hw",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + n + w = k + (n + w)", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b c : α}, a = b → b = c → a = c",
     "name": "trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k + (n + w) = k + m", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (k : Nat), n + k ≤ m + k",
     "name": "add_le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k ≤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k ≤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "k + n ≤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k ≤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "k + n ≤ k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "k + n ≤ k + m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k ≤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n ≤ m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (k : Nat), k + n ≤ k + m",
     "name": "Nat.add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + k ≤ m + k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → ∀ (k : Nat), k + n < k + m",
     "name": "add_lt_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_lt_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ m → n < m",
     "name": "lt_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "lt_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (k : Nat), k + n ≤ k + m",
     "name": "Nat.add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → succ n ≤ m",
     "name": "succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → ∀ (k : Nat), n + k < m + k",
     "name": "add_lt_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_lt_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → ∀ (k : Nat), k + n < k + m",
     "name": "Nat.add_lt_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_lt_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 1", "name": "zero_lt_one", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ":",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 < succ n",
     "name": "zero_lt_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "zero_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c d : Nat}, a ≤ b → c ≤ d → a + c ≤ b + d",
     "name": "add_le_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c ≤ d", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (k : Nat), n + k ≤ m + k",
     "name": "Nat.add_le_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (k : Nat), k + n ≤ k + m",
     "name": "Nat.add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c ≤ d", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c d : Nat}, a < b → c < d → a + c < b + d",
     "name": "add_lt_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_lt_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c < d", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m < k → n < k",
     "name": "Nat.lt_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → ∀ (k : Nat), n + k < m + k",
     "name": "Nat.add_lt_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_lt_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a < b", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → ∀ (k : Nat), k + n < k + m",
     "name": "Nat.add_lt_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_lt_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c < d", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a + b ≤ a + c → b ≤ c",
     "name": "le_of_add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b ≤ a + c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b ≤ a + c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "a + b + d = a + c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩ =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + (b + d) = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + (b + d) = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + (b + d) = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "a + b + d = a + c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ a + c",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = a + c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + m = n + k → m = k",
     "name": "Nat.add_left_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "a + (b + d) = a + c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a + b ≤ c + b → a ≤ c",
     "name": "le_of_add_le_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_add_le_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c + b → a ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c + b → a ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + a ≤ c + b → a ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c + b → a ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + a ≤ b + c → a ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b + a ≤ b + c → a ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c + b → a ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a + b ≤ a + c → b ≤ c",
     "name": "Nat.le_of_add_le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_add_le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- Basic theorems for comparing numerals -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "zero = 0", "name": "ctor_eq_zero", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ctor_eq_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "Nat.zero", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "1 ≠ 0", "name": "one_ne_zero", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "one_ne_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "1 = 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {P : Prop} {v1 v2 : Nat}, v1 = v2 → Nat.noConfusionType P v1 v2",
     "name": "Nat.noConfusion",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.noConfusion",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "1 = 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 ≠ 1", "name": "zero_ne_one", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_ne_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 = 1", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {P : Prop} {v1 v2 : Nat}, v1 = v2 → Nat.noConfusionType P v1 v2",
     "name": "Nat.noConfusion",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.noConfusion",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 = 1", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), succ n ≠ 0",
     "name": "succ_ne_zero",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_ne_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n = 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {P : Prop} {v1 v2 : Nat}, v1 = v2 → Nat.noConfusionType P v1 v2",
     "name": "Nat.noConfusion",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.noConfusion",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ n = 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- mul + order -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat} (k : Nat), n ≤ m → k * n ≤ k * m",
     "name": "mul_le_mul_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_le_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "l", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "l",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + l = m", "name": "hl", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩ =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "l", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "l",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m + k) = n * m + n * k",
     "name": "Nat.left_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "l", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "l",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + l = m", "name": "hl", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "k * n + k * l = k * m", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat} (k : Nat), n ≤ m → n * k ≤ m * k",
     "name": "mul_le_mul_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_le_mul_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat} (k : Nat), n ≤ m → k * n ≤ k * m",
     "name": "mul_le_mul_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_le_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n₁ m₁ n₂ m₂ : Nat}, n₁ ≤ n₂ → m₁ ≤ m₂ → n₁ * m₁ ≤ n₂ * m₂",
     "name": "mul_le_mul",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_le_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n₁ ≤ n₂", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m₁ ≤ m₂", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat} (k : Nat), n ≤ m → n * k ≤ m * k",
     "name": "mul_le_mul_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_le_mul_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n₁ ≤ n₂", "name": "h₁", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat} (k : Nat), n ≤ m → k * n ≤ k * m",
     "name": "mul_le_mul_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_le_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m₁ ≤ m₂", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → k > 0 → k * n < k * m",
     "name": "mul_lt_mul_of_pos_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_lt_mul_of_pos_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "k > 0", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m ≤ k → n < k",
     "name": "Nat.lt_of_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → ∀ (k : Nat), k + n < k + m",
     "name": "Nat.add_lt_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_lt_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "k > 0", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * succ m = n * m + n",
     "name": "Nat.mul_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat} (k : Nat), n ≤ m → k * n ≤ k * m",
     "name": "Nat.mul_le_mul_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_le_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → succ n ≤ m",
     "name": "succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "))\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → k > 0 → n * k < m * k",
     "name": "mul_lt_mul_of_pos_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_lt_mul_of_pos_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "k > 0", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → k > 0 → k * n < k * m",
     "name": "Nat.mul_lt_mul_of_pos_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_lt_mul_of_pos_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n < m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "k > 0", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n > 0 → m > 0 → n * m > 0",
     "name": "mul_pos",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_pos",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > 0", "name": "ha", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ha",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m > 0", "name": "hb", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hb",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 * m < n * m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → k > 0 → n * k < m * k",
     "name": "Nat.mul_lt_mul_of_pos_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_lt_mul_of_pos_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > 0", "name": "ha", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ha",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m > 0", "name": "hb", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hb",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 * n = 0",
     "name": "Nat.zero_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 * m < n * m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, c * a ≤ c * b → 0 < c → a ≤ b",
     "name": "le_of_mul_le_mul_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_of_mul_le_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c * a ≤ c * b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < c", "name": "hc", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, ¬n < m → n ≥ m",
     "name": "Nat.ge_of_not_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.ge_of_not_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b < a", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c * b < c * a", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → k > 0 → k * n < k * m",
     "name": "Nat.mul_lt_mul_of_pos_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_lt_mul_of_pos_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b < a", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < c", "name": "hc", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c * a ≤ c * b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n > m → ¬n ≤ m",
     "name": "Nat.not_le_of_gt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_le_of_gt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "c * b < c * a", "name": "h'", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m k n : Nat}, 0 < n → n * m = n * k → m = k",
     "name": "eq_of_mul_eq_mul_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_of_mul_eq_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < n", "name": "hn", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hn",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n * m = n * k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → m ≤ n → n = m",
     "name": "Nat.le_antisymm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_antisymm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, c * a ≤ c * b → 0 < c → a ≤ b",
     "name": "Nat.le_of_mul_le_mul_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_mul_le_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n = m → n ≤ m",
     "name": "Nat.le_of_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n * m = n * k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < n", "name": "hn", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hn",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n                  (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, c * a ≤ c * b → 0 < c → a ≤ b",
     "name": "Nat.le_of_mul_le_mul_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_mul_le_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n = m → n ≤ m",
     "name": "Nat.le_of_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n * m = n * k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < n", "name": "hn", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hn",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, 0 < m → n * m = k * m → n = k",
     "name": "eq_of_mul_eq_mul_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_of_mul_eq_mul_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < m", "name": "hm", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n * m = k * m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n * m = k * m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "m * n = m * k",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < m", "names": ["hm"], "body": "", "_type": "hypothesis"},
     {"type": "n * m = k * m",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n = k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m k n : Nat}, 0 < n → n * m = n * k → m = k",
     "name": "Nat.eq_of_mul_eq_mul_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_of_mul_eq_mul_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 < m", "name": "hm", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m * n = m * k", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- power -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n ^ succ m = n ^ m * n",
     "name": "pow_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pow_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^(",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ^ 0 = 1", "name": "pow_zero", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pow_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (i : Nat), n ^ i ≤ m ^ i",
     "name": "pow_le_pow_of_le_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pow_le_pow_of_le_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ∀ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n₁ m₁ n₂ m₂ : Nat}, n₁ ≤ n₂ → m₁ ≤ m₂ → n₁ * m₁ ≤ n₂ * m₂",
     "name": "Nat.mul_le_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_le_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → ∀ (i : Nat), n ^ i ≤ m ^ i",
     "name": "pow_le_pow_of_le_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pow_le_pow_of_le_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n > 0 → ∀ {i j : Nat}, i ≤ j → n ^ i ≤ n ^ j",
     "name": "pow_le_pow_of_le_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pow_le_pow_of_le_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > 0", "name": "hx", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hx",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ∀ {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "j", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "j",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "j", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "j",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "j", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "j",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i ≤ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n ≤ 0 → n = 0",
     "name": "eq_zero_of_le_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "eq_zero_of_le_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i ≤ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i = 0", "name": "this", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "j", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "j",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i ≤ succ j", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m n : Nat}, m ≤ succ n → m ≤ n ∨ m = succ n",
     "name": "le_or_eq_or_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le_or_eq_or_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i ≤ succ j", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i ≤ succ j", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "j", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "j",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "from",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "j", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "j",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n₁ m₁ n₂ m₂ : Nat}, n₁ ≤ n₂ → m₁ ≤ m₂ → n₁ * m₁ ≤ n₂ * m₂",
     "name": "Nat.mul_le_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_le_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n > 0 → ∀ {i j : Nat}, i ≤ j → n ^ i ≤ n ^ j",
     "name": "pow_le_pow_of_le_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pow_le_pow_of_le_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > 0", "name": "hx", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hx",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i ≤ j", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n > 0", "name": "hx", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hx",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n * 1 = n",
     "name": "Nat.mul_one",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "n ^ i * 1 ≤ n ^ j * n", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i = succ j", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n      ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i = succ j", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ▸ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n ≤ n", "name": "Nat.le_refl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_refl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat} (m : Nat), 0 < n → 0 < n ^ m",
     "name": "pos_pow_of_pos",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pos_pow_of_pos",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "^",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n > 0 → ∀ {i j : Nat}, i ≤ j → n ^ i ≤ n ^ j",
     "name": "pow_le_pow_of_le_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pow_le_pow_of_le_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 ≤ n", "name": "Nat.zero_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n/- min/max -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat → Nat", "name": "min", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "min",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "if",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "then",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "else",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat → Nat", "name": "max", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "max",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "if",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "then",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "else",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- Auxiliary theorems for well-founded recursion -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {b a : Nat}, b < a → a ≠ 0",
     "name": "not_eq_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_eq_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b < a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "b < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"},
     {"type": "b < zero", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero ≠ 0",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "n✝"], "body": "", "_type": "hypothesis"},
     {"type": "b < succ n✝",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n✝ ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "b < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "n✝"], "body": "", "_type": "hypothesis"},
     {"type": "b < succ n✝",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ n✝ ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b < zero", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), ¬n < 0",
     "name": "Nat.not_lt_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_lt_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "b < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {P : Prop} {v1 v2 : Nat}, v1 = v2 → Nat.noConfusionType P v1 v2",
     "name": "Nat.noConfusion",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.noConfusion",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, m < n → pred n < n",
     "name": "pred_lt'",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_lt'",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n ≠ 0 → pred n < n",
     "name": "pred_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {b a : Nat}, b < a → a ≠ 0",
     "name": "not_eq_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "not_eq_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m < n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n/- sub/pred theorems -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), a + b - a = b",
     "name": "add_sub_self_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_self_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + b - zero = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b - a = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (a + b) - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n + m = succ (n + m)",
     "name": "Nat.succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "Nat.succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b - a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a + b - a = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + b - succ a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b - a = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), a + b - b = a",
     "name": "add_sub_self_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_self_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b + a - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b + a - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b + a - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b - b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), a + b - a = b",
     "name": "add_sub_self_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_sub_self_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a i : Nat), a - i ≤ succ a - i",
     "name": "sub_le_succ_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_le_succ_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i ≤ succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i ≤ succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero ≤ succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero < succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → n ≤ m",
     "name": "Nat.le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero < succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - zero ≤ succ a - zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n < succ n",
     "name": "Nat.lt_succ_self",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_succ_self",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i ≤ succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i ≤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i ≤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) ≤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i ≤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) ≤ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "Nat.succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) ≤ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) ≤ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ i ≤ succ a - succ i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), pred n ≤ n",
     "name": "Nat.pred_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.pred_le",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {i a : Nat}, i < a → 0 < a - i",
     "name": "zero_lt_sub_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_lt_sub_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i < a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < zero", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < zero - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "i < a → 0 < a - i", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n = m ∨ n < m",
     "name": "Nat.eq_or_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_or_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "i < succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "i < succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i = a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "injection",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data types are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂`\nplaced in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂`\nshould be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data types are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂`\nplaced in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂`\nshould be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ i = succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data types are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂`\nplaced in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂`\nshould be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data types are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂`\nplaced in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂`\nshould be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " h",
    "link": null,
    "docstring":
    "The `injection` tactic is based on the fact that constructors of inductive data types are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂`\nplaced in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂`\nshould be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i = a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ i = succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "subst",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. ",
    "_type": "token"},
   {"typeinfo": {"type": "i = a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ i = succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < i + 1 - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "←",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n + 1 = succ n",
     "name": "Nat.add_one",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_one",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ i - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < 1",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (a b : Nat), a + b - a = b",
     "name": "Nat.add_sub_self_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_self_left",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < 1",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i"], "body": "", "_type": "hypothesis"},
     {"type": "i < i → 0 < i - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ i", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < 1",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ i = succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "decide",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "i < succ a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    | ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "i < succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n      ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ i < succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "0 < a - i",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "i < a → 0 < a - i", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n < succ m → n < m",
     "name": "Nat.lt_of_succ_lt_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_succ_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ i < succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["i", "a"], "body": "", "_type": "hypothesis"},
     {"type": "i < a → 0 < a - i",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ i < succ a",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "0 < succ a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n < m → m ≤ k → n < k",
     "name": "Nat.lt_of_lt_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_lt_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 < a - i", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a i : Nat), a - i ≤ succ a - i",
     "name": "Nat.sub_le_succ_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_le_succ_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a i : Nat), i < a → a - (i + 1) < a - i",
     "name": "sub_succ_lt_self",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_succ_lt_self",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "i < a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - succ (i + 0) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "Nat.add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (a - i) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "a",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - i ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n : Nat}, n ≠ 0 → pred n < n",
     "name": "Nat.pred_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.pred_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "a.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "?a.b✝ < a - i",
    "_type": "goal"},
   {"name": "a.b",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {b a : Nat}, b < a → a ≠ 0",
     "name": "Nat.not_eq_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_eq_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "a.h.h",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "i < a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {i a : Nat}, i < a → 0 < a - i",
     "name": "Nat.zero_lt_sub_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_lt_sub_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "i"], "body": "", "_type": "hypothesis"},
     {"type": "i < a", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - (i + 1) < a - i",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a : Nat}, a ≠ 0 → succ (pred a) = a",
     "name": "succ_pred",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "succ_pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≠ 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≠ 0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred a) = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≠ 0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred a) = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "zero ≠ 0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred zero) = zero",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≠ 0", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (pred a) = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n✝"], "body": "", "_type": "hypothesis"},
     {"type": "succ n✝ ≠ 0",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ (pred (succ n✝)) = succ n✝",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Nat}, a < b → b - a ≠ 0",
     "name": "sub_ne_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_ne_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "      => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), ¬n < n",
     "name": "Nat.lt_irrefl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_irrefl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "0 < succ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"},
     {"type": "0 < succ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ b - 0 ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ a < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → ¬a → b",
     "name": "absurd",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "absurd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ a < 0", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), ¬n < 0",
     "name": "Nat.not_lt_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_lt_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n  | ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ a < succ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ b - succ a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ b - succ a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b - a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "Nat.succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b - a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "b - a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "succ a < succ b",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ b - succ a ≠ 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Nat}, a < b → b - a ≠ 0",
     "name": "sub_ne_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_ne_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n < succ m → n < m",
     "name": "Nat.lt_of_succ_lt_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_of_succ_lt_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ a < succ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Nat}, a ≤ b → a + (b - a) = b",
     "name": "add_sub_of_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["b"], "body": "", "_type": "hypothesis"},
     {"type": "zero ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "zero + (b - zero) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "a ≤ b → a + (b - a) = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0",
      "names": ["hne"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b - a ≠ 0", "name": "hne", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hne",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Nat}, a < b → b - a ≠ 0",
     "name": "Nat.sub_ne_zero_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_ne_zero_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ a ≤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ m → n ≤ m",
     "name": "Nat.le_of_succ_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_succ_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "succ a ≤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + pred (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ (a + pred (b - a)) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n + m = succ (n + m)",
     "name": "Nat.succ_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + succ (pred (b - a)) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "Nat.add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + (b - a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ {a : Nat}, a ≠ 0 → succ (pred a) = a",
     "name": "Nat.succ_pred",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b - a ≠ 0", "name": "hne", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hne",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "succ a + (b - succ a) = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["b", "a"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b → a + (b - a) = b",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "succ a ≤ b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "b - a ≠ 0", "names": ["hne"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["this"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "a ≤ b → a + (b - a) = b", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "this", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, m ≤ n → n - m + m = n",
     "name": "sub_add_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_add_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "m ≤ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m ≤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m + m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m ≤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m + m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m ≤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m + (n - m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m ≤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m + m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "m ≤ n", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ {a b : Nat}, a ≤ b → a + (b - a) = b",
     "name": "Nat.add_sub_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "m ≤ n", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n k m : Nat), n + k - (m + k) = n - m",
     "name": "add_sub_add_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + zero - (m + zero) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n + k - (m + k) = n - m",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + succ k - (m + succ k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + k - (m + k) = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), succ n - succ m = n - m",
     "name": "succ_sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + k - (m + k) = n - m", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (k n m : Nat), k + n - (k + m) = n - m",
     "name": "add_sub_add_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + k - (m + k) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "k + n - (k + m) = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["k", "n", "m"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m = n - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n k m : Nat), n + k - (m + k) = n - m",
     "name": "Nat.add_sub_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m - m = n",
     "name": "add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "suffices",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - (0 + m) = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - (0 + m) = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), 0 + n = n",
     "name": "Nat.zero_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_add",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n + m - (0 + m) = n", "name": "this", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "this",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - m = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n + m - (0 + m) = n",
      "names": ["this"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n + m - m = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (0 + m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (0 + m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - 0 = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n k m : Nat), n + k - (m + k) = n - m",
     "name": "Nat.add_sub_add_right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (0 + m) = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), n - 0 = n",
     "name": "Nat.sub_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_zero",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m - n = m",
     "name": "add_sub_cancel_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_cancel_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "from",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (n + 0) = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (n + 0) = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m - 0 = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (k n m : Nat), k + n - (k + m) = n - m",
     "name": "Nat.add_sub_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - (n + 0) = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m = m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), n - 0 = n",
     "name": "Nat.sub_zero",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_zero",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m k : Nat}, k ≤ m → ∀ (n : Nat), n + m - k = n + (m - k)",
     "name": "add_sub_assoc",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_sub_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "k ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "w✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "Nat.le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "k ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rename_i",
    "link": null,
    "docstring":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "l", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "l",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "_type": "token"},
   {"typeinfo": {"type": "k + l = m", "name": "hl", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hl",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (k + l) - k = n + (k + l - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "k + l = m", "name": "hl", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (k + l) - k = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m - n = m",
     "name": "Nat.add_sub_cancel_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + (l + k) - k = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + l + k - k = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + m - k = n + (m - k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "intro",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "k"], "body": "", "_type": "hypothesis"},
     {"type": "k ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["n", "l"], "body": "", "_type": "hypothesis"},
     {"type": "k + l = m", "names": ["hl"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + l = n + l",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m - m = n",
     "name": "Nat.add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, b ≤ a → a - b = c → a = c + b",
     "name": "eq_add_of_sub_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "eq_add_of_sub_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a - b = c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = a - b + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": {"type": "a - b = c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a - b = c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ {n m : Nat}, m ≤ n → n - m + m = n",
     "name": "Nat.sub_add_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_add_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a = c + b → a - b = c",
     "name": "sub_eq_of_eq_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_eq_of_eq_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a = c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "c + b - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": {"type": "a = c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a = c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "c = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m - m = n",
     "name": "Nat.add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a - b ≤ c → a ≤ c + b",
     "name": "le_add_of_sub_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_add_of_sub_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a - b ≤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a - b ≤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (m n : Nat), m ≤ n ∨ n ≤ m",
     "name": "Nat.le_total",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_total",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n ≤ m + n",
     "name": "Nat.le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..)",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a - b + d = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + (a - b) = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m k : Nat}, k ≤ m → ∀ (n : Nat), n + m - k = n + (m - k)",
     "name": "Nat.add_sub_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "d + a - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "at",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a - b + d = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "d + a = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, b ≤ a → a - b = c → a = c + b",
     "name": "Nat.eq_add_of_sub_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_add_of_sub_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n ≤ m → m ≤ k → n ≤ k",
     "name": "Nat.le_trans",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_trans",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n ≤ m + n",
     "name": "Nat.le_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ..)) ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "d + a - b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a - b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "d + a = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a - b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "d + a = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "c + b = c + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": {"type": "d + a = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 - n = 0", "name": "zero_sub", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "zero_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses": [],
    "conclusion": "0 - zero = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "0 - n = 0", "names": ["ih"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - succ n = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 - n = 0", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "0 - n = 0", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n - (n + m) = 0",
     "name": "sub_self_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_self_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + 0 - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "show",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\n performs the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\n performs the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\n performs the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") - (",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\n performs the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\n performs the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\n performs the unification, and replaces the target with the unified version of `t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + 0 - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (k n m : Nat), k + n - (k + m) = n - m",
     "name": "Nat.add_sub_add_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_add_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n + 0 - (n + m) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), 0 - n = 0",
     "name": "Nat.zero_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_sub",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n - m = 0",
     "name": "sub_eq_zero_of_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_eq_zero_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n ≤ m", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩ => ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - (n + k) = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "n + k = m", "name": "hk", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"},
     {"type": "n ≤ m", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["k"], "body": "", "_type": "hypothesis"},
     {"type": "n + k = m", "names": ["hk"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 = 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n - (n + m) = 0",
     "name": "Nat.sub_self_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_self_add",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a ≤ c + b → a - b ≤ c",
     "name": "sub_le_of_le_add",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_le_of_le_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ c + b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (m n : Nat), m ≤ n ∨ n ≤ m",
     "name": "Nat.le_total",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_total",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | _, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → a ∨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n - m = 0",
     "name": "Nat.sub_eq_zero_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_zero_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ b", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "0 ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ b", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), 0 ≤ n", "name": "Nat.zero_le", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.zero_le",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩, ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, b → a ∨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d - b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a = c + b → a - b = c",
     "name": "Nat.sub_eq_of_eq_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_of_eq_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c + b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "d + (a - b) = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "d + a - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "← ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {m k : Nat}, k ≤ m → ∀ (n : Nat), n + m - k = n + (m - k)",
     "name": "Nat.add_sub_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "hge", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a - b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"},
     {"type": "a + d - b = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d - b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a ≤ c + b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c + b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ a", "names": ["hge"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a - b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d - b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, b ≤ c → a ≤ c - b → a + b ≤ c",
     "name": "add_le_of_le_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "add_le_of_le_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ c", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ c - b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a ≤ c - b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c - b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩ =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = a + d + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ {a b c : Nat}, b ≤ a → a - b = c → a = c + b",
     "name": "Nat.eq_add_of_sub_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.eq_add_of_sub_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ c", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d = c - b", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b + d = a + d + b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "b ≤ c", "names": ["hle"], "body": "", "_type": "hypothesis"},
     {"type": "a ≤ c - b", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + d = c - b",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + b ≤ c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "Nat.add_left_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a + b ≤ c → a ≤ c - b",
     "name": "le_sub_of_add_le",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "le_sub_of_add_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b ≤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "match",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → Exists fun k => n + k = m",
     "name": "le.dest",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.dest",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b ≤ c", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  | ⟨",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "a + b + d = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "⟩ =>\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " @",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m k : Nat}, n + k = m → n ≤ m",
     "name": "le.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "le.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a ≤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d + b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "d", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "d",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "c", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "c",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d + b = c",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [← ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + b + d = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n + m = m + n",
     "name": "Nat.add_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + m + k = n + (m + k)",
     "name": "Nat.add_assoc",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_assoc",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n + (m + k) = m + (n + k)",
     "name": "Nat.add_left_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_left_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a ≤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "c - b = a + d",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a + d = c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "c - b = a + d", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b c : Nat}, a = c + b → a - b = c",
     "name": "Nat.sub_eq_of_eq_add",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_of_eq_add",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a + d + b = c", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": "`have h := e` adds the hypothesis `h : t` if `e : t`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["a", "b", "c"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "a + b ≤ c", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["d"], "body": "", "_type": "hypothesis"},
     {"type": "a + b + d = c",
      "names": ["hd"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "a ≤ c - b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "c - b = a + d", "name": "hd", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hd",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "pred 0 = 0", "name": "pred_zero", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_zero",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), pred (succ n) = n",
     "name": "pred_succ",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pred_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "succ", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ {motive : Nat → Prop} (x y : Nat), (y ≤ x → ∀ (k : Nat), x = y + k → motive k) → (x < y → motive 0) → motive (x - y)",
     "name": "sub.elim",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub.elim",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "}\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
     "name": "h₁",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "x < y → motive 0", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n    : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Prop", "name": "motive", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "motive",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n < m ∨ n ≥ m",
     "name": "Nat.lt_or_ge",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.lt_or_ge",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| inl ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → n - m = 0",
     "name": "Nat.sub_eq_zero_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_eq_zero_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → n ≤ m",
     "name": "Nat.le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive 0",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inl",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y", "names": ["hlt"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y → motive 0", "name": "h₂", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₂",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x < y", "name": "hlt", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hlt",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "inr",
    "hypotheses":
    [{"type": "Nat → Prop",
      "names": ["motive"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "Nat", "names": ["x", "y"], "body": "", "_type": "hypothesis"},
     {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
      "names": ["h₁"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x < y → motive 0",
      "names": ["h₂"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "x ≥ y", "names": ["hle"], "body": "", "_type": "hypothesis"}],
    "conclusion": "motive (x - y)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| inr ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x ≥ y", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "y ≤ x → ∀ (k : Nat), x = y + k → motive k",
     "name": "h₁",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h₁",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x ≥ y", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Nat}, a ≤ b → a + (b - a) = b",
     "name": "Nat.add_sub_of_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_of_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "x ≥ y", "name": "hle", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hle",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "symm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), pred n * m = n * m - m",
     "name": "mul_pred_left",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_pred_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred n * m = n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred n * m = n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred zero * m = zero * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero   => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred n * m = n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n : Nat), pred (succ n) = n",
     "name": "Nat.pred_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.pred_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m = n * m + m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred (succ n) * m = succ n * m - m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m = n * m",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + m - m = n",
     "name": "Nat.add_sub_cancel",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_sub_cancel",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m : Nat), n * pred m = n * m - n",
     "name": "mul_pred_right",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_pred_right",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "pred", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pred",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "pred m * n = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "m * n - n = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), pred n * m = n * m - m",
     "name": "mul_pred_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "mul_pred_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * pred m = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n * m - n = n * m - n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n - m - k = n - (m + k)",
     "name": "sub_sub",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "sub_sub",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - k = n - (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - k = n - (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n - m - zero = n - (m + zero)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - k = n - (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "n - m - k = n - (m + k)", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - succ (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n + succ m = succ (n + m)",
     "name": "Nat.add_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.add_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - m - k) = n - succ (m + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - m - k) = pred (n - (m + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n - m - succ k = n - (m + succ k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "n - m - k = n - (m + k)",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - (m + k)) = pred (n - (m + k))",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "n - m - k = n - (m + k)", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), (n - m) * k = n * k - m * k",
     "name": "mul_sub_right_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_sub_right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k = n * k - m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k = n * k - m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "with",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "k"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(n - zero) * k = n * k - zero * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| zero => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "simp",
    "link": null,
    "docstring":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k = n * k - m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "| succ ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "(n - m) * k = n * k - m * k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "pred (n - m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n - succ m = pred (n - m)",
     "name": "Nat.sub_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - m) * k - k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), pred n * m = n * m - m",
     "name": "Nat.mul_pred_left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_pred_left",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * k - m * k - k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "(n - m) * k = n * k - m * k", "name": "ih", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "ih",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * k - m * k - k = n * k - (m * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), succ n * m = n * m + m",
     "name": "succ_mul",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "succ_mul",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * k - (m * k + k) = n * k - (m * k + k)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), n - m - k = n - (m + k)",
     "name": "Nat.sub_sub",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.sub_sub",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ";",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "succ",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "k", "m"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "(n - m) * k = n * k - m * k",
      "names": ["ih"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(n - succ m) * k = n * k - succ m * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "done",
    "link": null,
    "docstring": "`done` succeeds iff there are no remaining goals. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "protected",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n m k : Nat), n * (m - k) = n * m - n * k",
     "name": "mul_sub_left_distrib",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "mul_sub_left_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "rw",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(m - k) * n = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "m * n - k * n = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m k : Nat), (n - m) * k = n * k - m * k",
     "name": "Nat.mul_sub_right_distrib",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_sub_right_distrib",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m - k * n = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * (m - k) = n * m - n * k",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat",
      "names": ["n", "m", "k"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "n * m - k * n = n * m - k * n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo":
    {"type": "∀ (n m : Nat), n * m = m * n",
     "name": "Nat.mul_comm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.mul_comm",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "An abbreviation for `rewrite`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "k", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "k",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "]",
    "link": null,
    "docstring":
    "`rfl` is equivalent to `exact rfl`, but has a few optimizatons. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n/- Helper normalization theorems -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), (¬a ≤ b) = (b + 1 ≤ a)",
     "name": "not_le_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_le_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (¬ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬a ≤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, ¬n ≤ m → n > m",
     "name": "Nat.gt_of_not_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.gt_of_not_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬a ≤ b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b + 1 ≤ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n > m → ¬n ≤ m",
     "name": "Nat.not_le_of_gt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_le_of_gt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b + 1 ≤ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), (¬a ≥ b) = (a + 1 ≤ b)",
     "name": "not_ge_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_ge_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (¬ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≥ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), (¬a ≤ b) = (b + 1 ≤ a)",
     "name": "not_le_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "not_le_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), (¬a < b) = (b ≤ a)",
     "name": "not_lt_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_lt_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (¬ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " < ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
     "name": "propext",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "propext",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <| ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬a < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "have",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ b ≤ succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n < m → succ n ≤ m",
     "name": "Nat.succ_le_of_lt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_le_of_lt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, ¬n ≤ m → n > m",
     "name": "Nat.gt_of_not_le",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.gt_of_not_le",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "¬a < b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "); ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, succ n ≤ succ m → n ≤ m",
     "name": "Nat.le_of_succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.le_of_succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "succ b ≤ succ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n > m → ¬n ≤ m",
     "name": "Nat.not_le_of_gt",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.not_le_of_gt",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {n m : Nat}, n ≤ m → succ n ≤ succ m",
     "name": "Nat.succ_le_succ",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.succ_le_succ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "b ≤ a", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "))\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), (¬a > b) = (a ≤ b)",
     "name": "not_gt_eq",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "not_gt_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : (¬ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " > ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")) = (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≤ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), (¬a < b) = (b ≤ a)",
     "name": "not_lt_eq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "not_lt_eq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "end",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " Nat\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "namespace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " Prod\n\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat × Nat → α → α",
     "name": "foldI",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "foldI",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " × ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (Nat → α → α) → Nat → Nat → α → α",
     "name": "Nat.foldAux",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.foldAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → α → α", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → β", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → β", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → α", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat × Nat → Bool",
     "name": "anyI",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "anyI",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " × ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Nat → Bool",
     "name": "Nat.anyAux",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.anyAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → β", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → β", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → α", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n@[inline] ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat × Nat → Bool",
     "name": "allI",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "allI",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " × ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Nat → Bool) → Nat → Nat → Bool",
     "name": "Nat.anyAux",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat.anyAux",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => !",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Bool", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → β", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → β", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " - ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat × Nat", "name": "i", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "i",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α × β → α", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "end",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " Prod\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"}]