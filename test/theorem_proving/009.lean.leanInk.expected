[{"contents":
  [{"typeinfo":
    {"type": "‚àÄ (p q r : Prop), p ‚àß (q ‚à® r) ‚Üî p ‚àß q ‚à® p ‚àß r",
     "name": "example",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ‚àß (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ‚à® ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ‚Üî (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ‚àß ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ‚à® (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ‚àß ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üî p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, (a ‚Üí b) ‚Üí (b ‚Üí a) ‚Üí (a ‚Üî b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üî p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß (q ‚à® r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b c : Prop}, a ‚à® b ‚Üí (a ‚Üí c) ‚Üí (b ‚Üí c) ‚Üí c",
     "name": "Or.elim",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.elim",
    "link": null,
    "docstring":
    "Proof by cases on an `Or`. If `a ‚à® b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí b",
     "name": "And.right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.right",
    "link": null,
    "docstring":
    "Extract the right conjunct from a conjunction. `h : a ‚àß b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß (q ‚à® r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "q", "name": "hq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ‚àß q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚Üí a ‚à® b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ‚à® b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚Üí b ‚Üí a ‚àß b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a ‚Üí b ‚Üí a ‚àß b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a ‚àß b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß (q ‚à® r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "q", "name": "hq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "r", "name": "hr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, b ‚Üí a ‚à® b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a ‚à® b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚Üí b ‚Üí a ‚àß b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a ‚Üí b ‚Üí a ‚àß b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a ‚àß b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß (q ‚à® r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r ‚Üí p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß (q ‚à® r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "r", "name": "hr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r) ‚Üî p ‚àß q ‚à® p ‚àß r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß q ‚à® p ‚àß r", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b c : Prop}, a ‚à® b ‚Üí (a ‚Üí c) ‚Üí (b ‚Üí c) ‚Üí c",
     "name": "Or.elim",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.elim",
    "link": null,
    "docstring":
    "Proof by cases on an `Or`. If `a ‚à® b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß q ‚à® p ‚àß r", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß q", "name": "hpq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚Üí b ‚Üí a ‚àß b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a ‚Üí b ‚Üí a ‚àß b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a ‚àß b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß q", "name": "hpq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚Üí a ‚à® b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ‚à® b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n        ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí b",
     "name": "And.right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.right",
    "link": null,
    "docstring":
    "Extract the right conjunct from a conjunction. `h : a ‚àß b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß q", "name": "hpq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß q ‚à® p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß r", "name": "hpr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚Üí b ‚Üí a ‚àß b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a ‚Üí b ‚Üí a ‚àß b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a ‚àß b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß r", "name": "hpr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p ‚àß r ‚Üí p ‚àß (q ‚à® r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, b ‚Üí a ‚à® b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a ‚à® b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß q ‚à® p ‚àß r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p ‚àß r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ‚à® r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n        ",
    "link": null,
    "docstring":
    "`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! üêô",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí b",
     "name": "And.right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.right",
    "link": null,
    "docstring":
    "Extract the right conjunct from a conjunction. `h : a ‚àß b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p ‚àß r", "name": "hpr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents": [], "_type": "text"}]