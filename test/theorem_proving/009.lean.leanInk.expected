[{"contents":
  [{"typeinfo":
    {"type": "âˆ€ (p q r : Prop), p âˆ§ (q âˆ¨ r) â†” p âˆ§ q âˆ¨ p âˆ§ r",
     "name": "example",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " âˆ§ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " âˆ¨ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") â†” (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " âˆ§ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") âˆ¨ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " âˆ§ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†” p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ (a â†” b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Iff.intro",
    "link": null,
    "docstring": "If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†” p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ (q âˆ¨ r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Prop}, a âˆ¨ b â†’ (a â†’ c) â†’ (b â†’ c) â†’ c",
     "name": "Or.elim",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.elim",
    "link": null,
    "docstring":
    "Proof by cases on an `Or`. If `a âˆ¨ b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ b",
     "name": "And.right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.right",
    "link": null,
    "docstring":
    "Extract the right conjunct from a conjunction. `h : a âˆ§ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ (q âˆ¨ r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "q", "name": "hq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ b â†’ a âˆ§ b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a âˆ§ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ (q âˆ¨ r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.left.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "q", "name": "hq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "r", "name": "hr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ b â†’ a âˆ§ b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a âˆ§ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ (q âˆ¨ r)", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r â†’ p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mp.right.h.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ (q âˆ¨ r)", "names": ["h"], "body": "", "_type": "hypothesis"},
     {"type": "r", "names": ["hr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "r", "name": "hr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r) â†” p âˆ§ q âˆ¨ p âˆ§ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ q âˆ¨ p âˆ§ r", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b c : Prop}, a âˆ¨ b â†’ (a â†’ c) â†’ (b â†’ c) â†’ c",
     "name": "Or.elim",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.elim",
    "link": null,
    "docstring":
    "Proof by cases on an `Or`. If `a âˆ¨ b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ q âˆ¨ p âˆ§ r", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ q", "name": "hpq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ b â†’ a âˆ§ b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a âˆ§ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ q", "name": "hpq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
     "name": "Or.inl",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inl",
    "link": null,
    "docstring":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q", "names": ["hpq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n        ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ b",
     "name": "And.right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.right",
    "link": null,
    "docstring":
    "Extract the right conjunct from a conjunction. `h : a âˆ§ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ q", "name": "hpq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpq",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ q âˆ¨ p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ r", "name": "hpr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a â†’ b â†’ a âˆ§ b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.intro",
    "link": null,
    "docstring":
    "`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ a",
     "name": "And.left",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.left",
    "link": null,
    "docstring":
    "Extract the left conjunct from a conjunction. `h : a âˆ§ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ r", "name": "hpr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p âˆ§ r â†’ p âˆ§ (q âˆ¨ r)",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n      ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right.h",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
     "name": "Or.inr",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Or.inr",
    "link": null,
    "docstring":
    "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ q âˆ¨ p âˆ§ r",
      "names": ["h"],
      "body": "",
      "_type": "hypothesis"},
     {"type": "p âˆ§ r", "names": ["hpr"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q âˆ¨ r",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n        ",
    "link": null,
    "docstring":
    "`Â· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! ðŸ™",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ b",
     "name": "And.right",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "And.right",
    "link": null,
    "docstring":
    "Extract the right conjunct from a conjunction. `h : a âˆ§ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "p âˆ§ r", "name": "hpr", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hpr",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents": [], "_type": "text"}]