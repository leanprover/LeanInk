[{"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "import Mathlib.Tactic.Basic\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), a = b → b = a",
     "name": "example",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ∀ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "∀ (a b : Nat), a = b → b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a = b", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "introv",
    "link": null,
    "docstring":
    "The tactic `introv` allows the user to automatically introduce the variables of a theorem and\nexplicitly name the non-dependent hypotheses.\nAny dependent hypotheses are assigned their default names.\n\nExamples:\n```\nexample : ∀ a b : Nat, a = b → b = a := by\n  introv h,\n  exact h.symm\n```\nThe state after `introv h` is\n```\na b : ℕ,\nh : a = b\n⊢ b = a\n```\n\n```\nexample : ∀ a b : Nat, a = b → ∀ c, b = c → a = c := by\n  introv h₁ h₂,\n  exact h₁.trans h₂\n```\nThe state after `introv h₁ h₂` is\n```\na b : ℕ,\nh₁ : a = b,\nc : ℕ,\nh₂ : b = c\n⊢ a = c\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "The tactic `introv` allows the user to automatically introduce the variables of a theorem and\nexplicitly name the non-dependent hypotheses.\nAny dependent hypotheses are assigned their default names.\n\nExamples:\n```\nexample : ∀ a b : Nat, a = b → b = a := by\n  introv h,\n  exact h.symm\n```\nThe state after `introv h` is\n```\na b : ℕ,\nh : a = b\n⊢ b = a\n```\n\n```\nexample : ∀ a b : Nat, a = b → ∀ c, b = c → a = c := by\n  introv h₁ h₂,\n  exact h₁.trans h₂\n```\nThe state after `introv h₁ h₂` is\n```\na b : ℕ,\nh₁ : a = b,\nc : ℕ,\nh₂ : b = c\n⊢ a = c\n```\n",
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "∀ (a b : Nat), a = b → b = a",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "h", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "h",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a b : α}, a = b → b = a",
     "name": "symm",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "symm",
    "link": null,
    "docstring":
    "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (n : Nat), n = n", "name": "example", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses": [],
    "conclusion": "Nat.zero = Nat.zero",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat.succ n✝ = Nat.succ n✝",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "induction",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exacts",
    "link": null,
    "docstring":
    "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring":
    "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring":
    "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n",
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {α : Type} {a : α}, a = a", "name": "rfl", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "rfl",
    "link": null,
    "docstring":
    "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "]",
    "link": null,
    "docstring":
    "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "n = n",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exacts",
    "link": null,
    "docstring":
    "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " []",
    "link": null,
    "docstring":
    "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "example", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "guard_hyp",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["m"], "body": "1", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "let",
    "link": null,
    "docstring":
    "`let h : t := e` adds the hypothesis `h : t := e` to the current goal if `e` a term of type `t`.\nIf `t` is omitted, it will be inferred.\nThe variant `let pattern := e` is equivalent to `match e with | pattern => _`,\nand it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `let ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses\n`h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`let h : t := e` adds the hypothesis `h : t := e` to the current goal if `e` a term of type `t`.\nIf `t` is omitted, it will be inferred.\nThe variant `let pattern := e` is equivalent to `match e with | pattern => _`,\nand it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `let ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses\n`h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "`let h : t := e` adds the hypothesis `h : t := e` to the current goal if `e` a term of type `t`.\nIf `t` is omitted, it will be inferred.\nThe variant `let pattern := e` is equivalent to `match e with | pattern => _`,\nand it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `let ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses\n`h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "`let h : t := e` adds the hypothesis `h : t := e` to the current goal if `e` a term of type `t`.\nIf `t` is omitted, it will be inferred.\nThe variant `let pattern := e` is equivalent to `match e with | pattern => _`,\nand it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `let ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses\n`h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["m"], "body": "1", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "guard_hyp",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["m"], "body": "1", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "guard_hyp",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring":
    "Check that a named hypothesis has a given type and/or value.\n\n`guardHyp h : t` checks the type up to syntactic equality,\nwhile `guardHyp h :ₐ t` checks the type up to alpha equality.\n`guardHyp h := v` checks value up to syntactic equality,\nwhile `guardHyp h :=ₐ v` checks the value up to alpha equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"},
     {"type": "Nat", "names": ["m"], "body": "1", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "guard_target",
    "link": null,
    "docstring":
    "Check the target agrees (syntactically) with a given expression.\nSee also `guardTarget` and `guardTarget'` for testing\nup to alpha equality and definitional equality. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " == ",
    "link": null,
    "docstring":
    "Check the target agrees (syntactically) with a given expression.\nSee also `guardTarget` and `guardTarget'` for testing\nup to alpha equality and definitional equality. ",
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "0", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "0",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), a ≠ b → ¬a = b",
     "name": "example",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ≠ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≠ b → ¬a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "¬a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intros",
    "link": null,
    "docstring":
    "`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous)\nhypotheses until goal is not of a function type.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≠ b → ¬a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "a = b", "names": ["H"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by_contra",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": {"type": "a = b", "name": "H", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "H",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a ≠ b → ¬a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (a b : Nat), ¬¬a = b → a = b",
     "name": "example",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ¬¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " = ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "¬¬a = b → a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intros",
    "link": null,
    "docstring":
    "`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous)\nhypotheses until goal is not of a function type.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "¬¬a = b → a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"},
     {"type": "¬a = b", "names": ["H"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by_contra",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": {"type": "¬a = b", "name": "H", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "H",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["a", "b"], "body": "", "_type": "hypothesis"}],
    "conclusion": "¬¬a = b → a = b",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (p q : Prop), ¬¬p → p", "name": "example", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages":
  [{"contents": "Warning: unused variable `q` [linter.unusedVariables]",
    "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ¬¬ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "¬¬p → p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intros",
    "link": null,
    "docstring":
    "`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous)\nhypotheses until goal is not of a function type.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "¬¬p → p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "h",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "¬p", "names": ["H"], "body": "", "_type": "hypothesis"}],
    "conclusion": "False",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by_contra",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": {"type": "¬p", "name": "H", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "H",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "¬¬p → p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "contradiction",
    "link": null,
    "docstring":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n-- Test `iterate n ...`\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Unit", "name": "example", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Unit", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Unit",
    "link": null,
    "docstring":
    "The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.zero",
    "hypotheses": [],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "zero.succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.zero",
    "hypotheses": [],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "zero.succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "iterate",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " 3 ",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Unit", "name": "()", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "()",
    "link": null,
    "docstring":
    "`Unit.unit : Unit` is the canonical element of the unit type.\nIt can also be written as `()`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n-- Test `iterate ...`, which should repeat until failure.\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Unit", "name": "example", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Unit", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Unit",
    "link": null,
    "docstring":
    "The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero",
    "hypotheses":
    [{"type": "Nat", "names": ["m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.zero",
    "hypotheses": [],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "zero.succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "cases",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "m", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "m",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n", "m"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "zero.zero",
    "hypotheses": [],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "zero.succ",
    "hypotheses":
    [{"type": "Nat", "names": ["n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"},
   {"name": "succ",
    "hypotheses":
    [{"type": "Nat", "names": ["m", "n✝"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Unit",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "iterate",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Unit", "name": "()", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "()",
    "link": null,
    "docstring":
    "`Unit.unit : Unit` is the canonical element of the unit type.\nIt can also be written as `()`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat → Nat", "name": "example", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "iterate",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Unit", "name": "()", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "()",
    "link": null,
    "docstring":
    "`Unit.unit : Unit` is the canonical element of the unit type.\nIt can also be written as `()`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " -- silently succeeds, after iterating 0 times\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Nat", "names": ["n"], "body": "", "_type": "hypothesis"}],
    "conclusion": "Nat",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "iterate",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "n", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "∀ (p q r s : Prop), p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ p ∧ r ∧ q",
     "name": "example",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ∧ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ∧ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "r", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "r",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ p ∧ r ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(p ∧ q) ∧ (r ∧ s ∧ p) ∧ p ∧ r ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intros",
    "link": null,
    "docstring":
    "`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous)\nhypotheses until goal is not of a function type.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ p ∧ r ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "(p ∧ q) ∧ (r ∧ s ∧ p) ∧ p ∧ r ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "repeat'",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "right.left.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "constructor",
    "link": null,
    "docstring":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ p ∧ r ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "left.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"},
   {"name": "right.left.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"},
   {"name": "right.left.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "s",
    "_type": "goal"},
   {"name": "right.left.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "right.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "right.right.right.left",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "r",
    "_type": "goal"},
   {"name": "right.right.right.right",
    "hypotheses":
    [{"type": "Prop",
      "names": ["p", "q", "r", "s"],
      "body": "",
      "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "repeat'",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (p q : Prop), p → q → (p ∧ q) ∧ p ∧ q ∧ p",
     "name": "example",
     "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "example",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ∧ (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") := ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p → q → (p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "by",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "(p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "intros",
    "link": null,
    "docstring":
    "`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous)\nhypotheses until goal is not of a function type.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p → q → (p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q",
    "_type": "goal"},
   {"name": "right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "constructor",
    "link": null,
    "docstring":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p → q → (p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q",
    "_type": "goal"},
   {"name": "right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fail_if_success",
    "link": null,
    "docstring": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q",
    "_type": "goal"},
   {"name": "right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "any_goals",
    "link": null,
    "docstring": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p → q → (p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q",
    "_type": "goal"},
   {"name": "right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "all_goals",
    "link": null,
    "docstring":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "right.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "right.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "constructor",
    "link": null,
    "docstring":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p → q → (p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "left.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "left.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"},
   {"name": "right.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "right.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "any_goals",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "right.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p → q → (p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "right.right.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"},
   {"name": "right.right.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "constructor",
    "link": null,
    "docstring":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p → q → (p ∧ q) ∧ p ∧ q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "right.right.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"},
   {"name": "right.right.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "any_goals",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring":
    "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ",
    "_type": "token"}],
  "_type": "sentence"},
 {"messages": [],
  "goals":
  [{"name": "",
    "hypotheses": [],
    "conclusion": "Goals accomplished! 🐙",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "assumption",
    "link": null,
    "docstring":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "_type": "token"}],
  "_type": "sentence"},
 {"contents": [], "_type": "text"}]